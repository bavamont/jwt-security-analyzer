const i18n = {
    currentLanguage: 'en',
    translations: {
        en: {
            'app.title': 'JWT Security Analyzer',
            'app.subtitle': 'JWT Token Analysis & Security Testing Suite',

            'window.minimize': 'Minimize',
            'window.maximize': 'Maximize',
            'window.restore': 'Restore',
            'window.close': 'Close',

            'nav.decoder': 'JWT Decoder',
            'nav.decoder.tooltip': 'Decode and analyze JWT tokens',
            'nav.encoder': 'JWT Encoder',
            'nav.encoder.tooltip': 'Create custom JWT tokens',
            'nav.security': 'Security Analysis',
            'nav.security.tooltip': 'Vulnerability detection and analysis',
            'nav.attacks': 'Attack Vectors',
            'nav.attacks.tooltip': 'Generate attack payloads',
            'nav.bruteforce': 'Brute Force',
            'nav.bruteforce.tooltip': 'Crack weak secrets',
            'nav.keygen': 'Key Generator',
            'nav.keygen.tooltip': 'Generate RSA/HMAC keys',
            'nav.validator': 'Token Validator',
            'nav.validator.tooltip': 'Verify token integrity',
            'nav.utilities': 'UTILITIES',
            'nav.http_tester': 'HTTP Tester',
            'nav.http_tester.tooltip': 'Test JWT tokens in requests',
            'nav.base64': 'Base64 Tools',
            'nav.base64.tooltip': 'Encode/decode Base64',
            'nav.help': 'Help',
            'nav.help.tooltip': 'Usage guide and documentation',

            'decoder.title': 'JWT Token Decoder',
            'decoder.subtitle': 'Decode and analyze JWT tokens to view their structure and claims',
            'decoder.token_input': 'JWT Token Input',
            'decoder.jwt_token': 'JWT Token',
            'decoder.jwt_placeholder': 'Paste your JWT token here...',
            'decoder.input_help': 'Paste a complete JWT token (header.payload.signature)',
            'decoder.decode_token': 'Decode Token',
            'decoder.clear': 'Clear',
            'decoder.load_example': 'Load Example',
            'decoder.token_structure': 'Token Structure',
            'decoder.valid': 'Valid',
            'decoder.invalid': 'Invalid',
            'decoder.send_to_encoder': 'Send to Encoder',
            'decoder.header': 'Header',
            'decoder.payload': 'Payload',
            'decoder.signature': 'Signature',
            'decoder.copy': 'Copy',
            'decoder.base64_encoded': 'Base64 Encoded:',
            'decoder.decoded_json': 'Decoded JSON:',
            'decoder.algorithm': 'Algorithm:',
            'decoder.length': 'Length:',
            'decoder.status': 'Status:',
            'decoder.unknown': 'Unknown',
            'decoder.claims_analysis': 'Claims Analysis',
            'decoder.no_signature': 'No Signature',
            'decoder.missing': 'Missing',
            'decoder.present': 'Present',

            'encoder.title': 'JWT Token Encoder',
            'encoder.subtitle': 'Create custom JWT tokens with any header, payload, and signature',
            'encoder.token_config': 'Token Configuration',
            'encoder.header': 'Header',
            'encoder.payload': 'Payload',
            'encoder.header_placeholder': '{\n  "alg": "HS256",\n  "typ": "JWT"\n}',
            'encoder.payload_placeholder': '{\n  "sub": "1234567890",\n  "name": "John Doe",\n  "iat": 1516239022\n}',
            'encoder.algorithm': 'Algorithm',
            'encoder.hs256': 'HS256 (HMAC SHA-256)',
            'encoder.hs384': 'HS384 (HMAC SHA-384)',
            'encoder.hs512': 'HS512 (HMAC SHA-512)',
            'encoder.rs256': 'RS256 (RSA SHA-256)',
            'encoder.rs384': 'RS384 (RSA SHA-384)',
            'encoder.rs512': 'RS512 (RSA SHA-512)',
            'encoder.es256': 'ES256 (ECDSA SHA-256)',
            'encoder.es384': 'ES384 (ECDSA SHA-384)',
            'encoder.es512': 'ES512 (ECDSA SHA-512)',
            'encoder.ps256': 'PS256 (RSASSA-PSS SHA-256)',
            'encoder.ps384': 'PS384 (RSASSA-PSS SHA-384)',
            'encoder.ps512': 'PS512 (RSASSA-PSS SHA-512)',
            'encoder.none': 'none (No signature)',
            'encoder.secret_key': 'Secret/Private Key',
            'encoder.secret_placeholder': 'Enter your secret or private key...',
            'encoder.secret_help': 'For HMAC: Enter secret string. For RSA: Enter private key in PEM format.',
            'encoder.generate_token': 'Generate Token',
            'encoder.clear_all': 'Clear All',
            'encoder.load_template': 'Load Template',
            'encoder.generated_token': 'Generated Token',
            'encoder.copy_token': 'Copy Token',
            'encoder.test_token': 'Test Token',

            'security.title': 'Security Analysis',
            'security.subtitle': 'Comprehensive vulnerability analysis for JWT tokens',
            'security.token_scanner': 'Token Security Scanner',
            'security.jwt_to_analyze': 'JWT Token to Analyze',
            'security.jwt_placeholder': 'Paste JWT token for security analysis...',
            'security.analyze_security': 'Analyze Security',
            'security.security_assessment': 'Security Assessment',
            'security.security_score': 'Security Score:',
            'security.critical': 'Critical',
            'security.high': 'High',
            'security.medium': 'Medium',
            'security.low': 'Low',
            'security.info': 'Info',

            'attacks.title': 'Attack Vectors',
            'attacks.subtitle': 'Generate attack payloads for common JWT vulnerabilities',
            'attacks.attack_generator': 'Attack Generator',
            'attacks.target_jwt': 'Target JWT Token',
            'attacks.target_placeholder': 'Paste target JWT token here...',
            'attacks.attacks': 'Attacks',
            'attacks.generate_attack': 'Generate Attack',
            'attacks.generated_payloads': 'Generated Attack Payloads',

            'attacks.none': 'Algorithm None',
            'attacks.confusion': 'Algorithm Confusion',
            'attacks.replay': 'Token Replay',
            'attacks.weak-secret': 'Weak Secret',
            'attacks.jwk-injection': 'JWK Injection',
            'attacks.kid-injection': 'Kid Parameter Injection',
            'attacks.jku-hijack': 'JKU URL Hijacking',
            'attacks.x5u-exploit': 'X5U Certificate Exploit',
            'attacks.jwt-smuggling': 'JWT Smuggling',
            'attacks.nested-jwt': 'Nested JWT Attack',
            'attacks.audience-confusion': 'Audience Confusion',
            'attacks.parameter-pollution': 'Parameter Pollution',
            'attacks.timing-attack': 'Timing Attack',
            'attacks.jwt-sidejacking': 'JWT Sidejacking',
            'attacks.jwks-poisoning': 'JWKS Cache Poisoning',
            'attacks.quantum-prep': 'Quantum-Prep Attack',

            'attacks.algorithm_none': 'Algorithm None',
            'attacks.algorithm_none_desc': 'Remove signature verification by setting algorithm to "none"',
            'attacks.algorithm_confusion': 'Algorithm Confusion',
            'attacks.algorithm_confusion_desc': 'Change RS256 to HS256 using public key as HMAC secret',
            'attacks.weak_secret': 'Weak Secret',
            'attacks.weak_secret_desc': 'Exploit weak HMAC secrets using dictionary attacks',
            'attacks.token_replay': 'Token Replay',
            'attacks.token_replay_desc': 'Reuse tokens across different sessions or environments',
            'attacks.jwk_injection': 'JWK Injection',
            'attacks.jwk_injection_desc': 'Inject malicious JWK in header to bypass signature verification',
            'attacks.kid_injection': 'Kid Parameter Injection',
            'attacks.kid_injection_desc': 'Path traversal and injection via the "kid" header parameter',
            'attacks.jku_hijack': 'JKU URL Hijacking',
            'attacks.jku_hijack_desc': 'Point JKU to attacker-controlled JWK set',
            'attacks.x5u_exploit': 'X5U Certificate Exploit',
            'attacks.x5u_exploit_desc': 'Exploit X.509 certificate URL parameter',
            'attacks.jwt_smuggling': 'JWT Smuggling',
            'attacks.jwt_smuggling_desc': 'Exploit parsing differences between JWT libraries',
            'attacks.nested_jwt': 'Nested JWT Attack',
            'attacks.nested_jwt_desc': 'JWT inside JWT confusion and privilege escalation',
            'attacks.audience_confusion': 'Audience Confusion',
            'attacks.audience_confusion_desc': 'Multi-audience token reuse across services',
            'attacks.parameter_pollution': 'Parameter Pollution',
            'attacks.parameter_pollution_desc': 'Duplicate parameters with conflicting values',
            'attacks.timing_attack': 'Timing Attack',
            'attacks.timing_attack_desc': 'Exploit timing differences in signature verification',
            'attacks.jwt_sidejacking': 'JWT Sidejacking',
            'attacks.jwt_sidejacking_desc': 'Session hijacking specific to JWT implementations',
            'attacks.jwks_poisoning': 'JWKS Cache Poisoning',
            'attacks.jwks_poisoning_desc': 'Poison JWKS cache with malicious keys',
            'attacks.quantum_prep': 'Quantum-Prep Attack',
            'attacks.quantum_prep_desc': 'Test quantum-vulnerable algorithms and key sizes',

            'attacks.none_title': 'Algorithm None Attack Explained',
            'attacks.confusion_title': 'Algorithm Confusion Attack Explained',
            'attacks.weak_secret_title': 'Weak Secret Attack Explained',
            'attacks.replay_title': 'Token Replay Attack Explained',
            'attacks.jwk_injection_title': 'JWK Injection Attack Explained',
            'attacks.kid_injection_title': 'Kid Parameter Injection Attack Explained',
            'attacks.jku_hijack_title': 'JKU URL Hijacking Attack Explained',
            'attacks.x5u_exploit_title': 'X5U Certificate Exploit Explained',
            'attacks.jwt_smuggling_title': 'JWT Smuggling Attack Explained',
            'attacks.nested_jwt_title': 'Nested JWT Attack Explained',
            'attacks.audience_confusion_title': 'Audience Confusion Attack Explained',
            'attacks.parameter_pollution_title': 'Parameter Pollution Attack Explained',
            'attacks.timing_attack_title': 'Timing Attack Explained',
            'attacks.jwt_sidejacking_title': 'JWT Sidejacking Attack Explained',
            'attacks.jwks_poisoning_title': 'JWKS Cache Poisoning Attack Explained',
            'attacks.quantum_prep_title': 'Quantum-Prep Attack Explained',

            'attacks.how_none_works': 'The "none" algorithm attack works by changing the JWT header\'s algorithm field from a secure signing algorithm (like HS256 or RS256) to "none". This tells the server to skip signature verification entirely. The server processes the token as valid without checking if it was actually signed by the legitimate issuer. Attackers can modify any part of the payload (like changing user roles from "user" to "admin") and the application will accept it as authentic.',

            'attacks.how_confusion_works': 'Algorithm confusion exploits applications that use both RSA (asymmetric) and HMAC (symmetric) algorithms. In RSA, tokens are signed with a private key and verified with a public key. In HMAC, the same secret is used for both signing and verification. The attack works by: 1) Obtaining the RSA public key (often publicly available), 2) Changing the token\'s algorithm from RS256 to HS256, 3) Using the public key as an HMAC secret to sign the modified token. The server, configured to use the public key for verification, unknowingly validates the attacker\'s signature.',

            'attacks.how_weak_secret_works': 'Weak secret attacks target HMAC-signed JWTs that use predictable or common secrets like "secret", "password", or "key". Since HMAC uses symmetric encryption, if an attacker can guess the secret, they can forge valid tokens. The attack involves: 1) Taking a legitimate JWT, 2) Trying common passwords from wordlists, 3) Attempting to recreate the signature using each password, 4) When the signature matches, the secret is discovered and can be used to create arbitrary valid tokens.',

            'attacks.how_replay_works': 'Token replay attacks exploit JWTs that lack proper time-based restrictions. By removing or modifying claims like "exp" (expiration), "nbf" (not before), and "iat" (issued at), attackers can reuse tokens indefinitely. The attack works by: 1) Intercepting a valid JWT, 2) Removing time-based claims from the payload, 3) Keeping the original signature intact, 4) Reusing the token across different sessions, times, or even different users if the application doesn\'t properly validate the token context.',

            'attacks.how_jwk_injection_works': 'JWK injection exploits the "jwk" header parameter that allows embedding a public key directly in the JWT header. When servers trust this embedded key for verification, attackers can: 1) Generate their own RSA key pair, 2) Embed their public key in the JWT header using the "jwk" parameter, 3) Sign the token with their private key, 4) Modify the payload as desired. The server uses the attacker\'s embedded public key to verify the signature, making the malicious token appear valid.',

            'attacks.how_kid_injection_works': 'The "kid" (Key ID) parameter tells the server which key to use for verification. Applications often use this value in file operations or database queries without proper sanitization. Attack vectors include: 1) Path traversal: "../../../etc/passwd" to access sensitive files, 2) SQL injection: "\' OR \'1\'=\'1" to manipulate database queries, 3) Command injection: "key; rm -rf /" to execute system commands, 4) Directory traversal to load arbitrary files as verification keys.',

            'attacks.how_jku_hijack_works': 'JKU (JSON Web Key Set URL) hijacking exploits the "jku" parameter that points to a URL containing public keys for verification. Attackers can: 1) Change the "jku" URL to point to their controlled server, 2) Host their own JWKS with malicious public keys, 3) Sign tokens with the corresponding private keys, 4) The application fetches keys from the attacker\'s URL and uses them for verification. This can also lead to SSRF (Server-Side Request Forgery) vulnerabilities.',

            'attacks.how_x5u_exploit_works': 'The "x5u" parameter specifies a URL for X.509 certificate chains used in token verification. Similar to JKU attacks, attackers can: 1) Point "x5u" to their malicious certificate server, 2) Create fake certificate chains, 3) Sign tokens with corresponding private keys, 4) The application downloads and trusts the malicious certificates. This attack can also exploit certificate parsing vulnerabilities and enable SSRF attacks.',

            'attacks.how_jwt_smuggling_works': 'JWT smuggling exploits differences in how various JWT libraries parse tokens. Techniques include: 1) Double headers: Adding multiple header sections that different libraries interpret differently, 2) Embedded JWTs: Placing complete JWTs within payload fields, 3) Malformed structures: Using unusual formatting that causes parsing inconsistencies, 4) Character encoding tricks: Exploiting Unicode or encoding differences. One library might validate the outer token while another processes an inner malicious token.',

            'attacks.how_nested_jwt_works': 'Nested JWT attacks place one JWT inside another JWT\'s payload. This can cause confusion in applications that process multiple token layers: 1) The outer JWT is validated normally, 2) The application extracts and processes an inner JWT from the payload, 3) The inner JWT might have different claims (like elevated privileges), 4) If the application doesn\'t properly validate the inner token\'s context, it might grant unintended access based on the nested token\'s claims.',

            'attacks.how_audience_confusion_works': 'Audience confusion exploits weak validation of the "aud" (audience) claim, which specifies which services should accept the token. Attacks include: 1) Multi-audience tokens: Creating tokens valid for multiple services, 2) Missing audience validation: Tokens without "aud" claims accepted everywhere, 3) Wildcard audiences: Using "*" or empty strings as audience values, 4) Cross-service token reuse: Using tokens meant for one service to access another. This enables privilege escalation across different application components.',

            'attacks.how_parameter_pollution_works': 'Parameter pollution exploits JSON parsers that handle duplicate keys differently. Some parsers use the first occurrence, others use the last. Examples: 1) {"alg":"HS256","alg":"none"} - first parser sees HS256, second sees none, 2) {"sub":"user","sub":"admin"} - creates conflicting identity claims, 3) Different libraries handling the same malformed JSON differently can lead to security bypasses where validation uses one value but authorization uses another.',

            'attacks.how_timing_attack_works': 'Timing attacks exploit measurable differences in signature verification time. By sending many tokens with different signatures and measuring response times, attackers can: 1) Detect valid vs invalid signatures based on processing time, 2) Gradually reconstruct valid signatures by analyzing timing patterns, 3) Bypass rate limiting by identifying which signatures cause longer processing, 4) Extract information about the server\'s key material through statistical analysis of response times.',

            'attacks.how_jwt_sidejacking_works': 'JWT sidejacking targets session management vulnerabilities specific to JWT implementations: 1) Session fixation: Forcing users to use attacker-controlled JTIs (JWT IDs), 2) Token hijacking: Stealing JWTs from insecure storage or transmission, 3) Cross-site token theft: Using XSS to steal JWTs from client storage, 4) Network interception: Capturing JWTs from unencrypted connections, 5) Long-lived tokens: Exploiting JWTs without proper expiration for persistent access.',

            'attacks.how_jwks_poisoning_works': 'JWKS cache poisoning targets applications that cache JSON Web Key Sets for performance. Attackers can: 1) Force cache updates with malicious JWKS data, 2) Exploit cache timing to inject malicious keys, 3) Use cache pollution techniques to replace legitimate keys, 4) Leverage TTL (Time To Live) manipulation to extend malicious key lifetime, 5) Poison shared caches affecting multiple applications. Once poisoned, all tokens verified against the cache use attacker-controlled keys.',

            'attacks.how_quantum_prep_works': 'Quantum preparedness testing evaluates JWT resistance to future quantum computing attacks. Current RSA and ECDSA algorithms will become vulnerable when large-scale quantum computers exist. The assessment: 1) Identifies quantum-vulnerable algorithms (RSA, ECDSA), 2) Estimates breaking timeline (2030-2040 for RSA-2048), 3) Tests key sizes and their quantum resistance, 4) Recommends migration to post-quantum cryptography algorithms like CRYSTALS-Dilithium, FALCON, or SPHINCS+.',

            'modal.attack_explanation': 'Attack Explanation',
            'modal.close': 'Close',
            'modal.how_it_works': 'How it works',
            'modal.cancel': 'Cancel',
            'modal.confirm': 'Confirm',
            'modal.ok': 'OK',

            'bruteforce.title': 'Secret Brute Force',
            'bruteforce.subtitle': 'Crack weak HMAC secrets using dictionary attacks',
            'bruteforce.config': 'Brute Force Configuration',
            'bruteforce.target_token': 'Target Token',
            'bruteforce.token_placeholder': 'Paste JWT token with HMAC signature...',
            'bruteforce.secret_wordlist': 'Secret Wordlist',
            'bruteforce.wordlist_placeholder': 'Enter secrets to test, one per line...',
            'bruteforce.load_common': 'Load Common Secrets',
            'bruteforce.load_file': 'Load File',
            'bruteforce.start': 'Start Brute Force',
            'bruteforce.stop': 'Stop',
            'bruteforce.in_progress': 'Brute Force in Progress',
            'bruteforce.testing_secrets': 'Testing secrets...',
            'bruteforce.current': 'Current:',
            'bruteforce.tested': 'Tested:',
            'bruteforce.remaining': 'Remaining:',
            'bruteforce.speed': 'Speed:',
            'bruteforce.secret_cracked': 'Secret Cracked!',
            'bruteforce.discovered_secret': 'Discovered Secret:',
            'bruteforce.copy': 'Copy',
            'bruteforce.use_in_encoder': 'Use in Encoder',
            'bruteforce.generate_new_tokens': 'Generate New Tokens',

            'keygen.title': 'Key Generator',
            'keygen.subtitle': 'Generate secure keys for JWT token signing',
            'keygen.key_generation': 'Key Generation',
            'keygen.hmac_secrets': 'HMAC Secrets',
            'keygen.secret_length': 'Secret Length:',
            'keygen.256_bit': '256-bit (32 bytes)',
            'keygen.384_bit': '384-bit (48 bytes)',
            'keygen.512_bit': '512-bit (64 bytes)',
            'keygen.generate_hmac': 'Generate HMAC Secret',
            'keygen.generated_secret': 'Generated Secret:',
            'keygen.copy': 'Copy',
            'keygen.rsa_keypairs': 'RSA Key Pairs',
            'keygen.key_size': 'Key Size:',
            'keygen.2048_bit': '2048-bit',
            'keygen.3072_bit': '3072-bit',
            'keygen.4096_bit': '4096-bit',
            'keygen.generate_rsa': 'Generate RSA Keys',
            'keygen.private_key': 'Private Key:',
            'keygen.public_key': 'Public Key:',

            'validator.title': 'Token Validator',
            'validator.subtitle': 'Verify JWT token signatures and validate claims',
            'validator.token_validation': 'Token Validation',
            'validator.jwt_token': 'JWT Token',
            'validator.token_placeholder': 'Paste JWT token to validate...',
            'validator.secret_key': 'Secret/Public Key',
            'validator.key_placeholder': 'Enter secret or public key...',
            'validator.validate_token': 'Validate Token',
            'validator.signature_only': 'Signature Only',
            'validator.validation_results': 'Validation Results',

            'http.title': 'HTTP Tester',
            'http.subtitle': 'Test JWT tokens in HTTP requests',
            'http.request_builder': 'HTTP Request Builder',
            'http.url_placeholder': 'https://api.example.com/endpoint',
            'http.send': 'Send',
            'http.headers': 'Headers',
            'http.body': 'Body',
            'http.authorization': 'Authorization',
            'http.headers_placeholder': 'Content-Type: application/json\nUser-Agent: JWT-Analyzer',
            'http.body_placeholder': '{\n  "data": "example"\n}',
            'http.bearer_token': 'Bearer Token',
            'http.custom_header': 'Custom Header',
            'http.token_placeholder': 'Paste JWT token here...',
            'http.response': 'Response',
            'http.response_body': 'Response',
            'http.response_headers': 'Headers',

            'base64.title': 'Base64 Tools',
            'base64.subtitle': 'Encode and decode Base64 strings',
            'base64.encoder_decoder': 'Base64 Encoder/Decoder',
            'base64.plain_text': 'Plain Text',
            'base64.base64': 'Base64',
            'base64.plain_placeholder': 'Enter plain text to encode...',
            'base64.base64_placeholder': 'Enter Base64 string to decode...',
            'base64.encode': 'Encode',
            'base64.decode': 'Decode',

            'help.title': 'Help & Documentation',
            'help.subtitle': 'Learn how to use JWT Security Analyzer effectively',
            'help.getting_started': 'Getting Started',
            'help.step1': 'Start with the JWT Decoder to analyze existing tokens and understand their structure',
            'help.step2': 'Use the JWT Encoder to create custom tokens with your own header, payload, and signature',
            'help.step3': 'Run Security Analysis to identify potential vulnerabilities in your tokens',
            'help.step4': 'Generate Attack Vectors to test your application\'s JWT implementation',
            'help.step5': 'Use Brute Force to test the strength of HMAC secrets',
            'help.step6': 'Generate secure keys with the Key Generator for production use',
            'help.key_features': 'Key Features:',
            'help.feature1': 'Comprehensive JWT token decoding and analysis',
            'help.feature2': 'Custom token generation with multiple algorithms',
            'help.feature3': 'Advanced security vulnerability detection',
            'help.feature4': '16+ attack vector generators for penetration testing',
            'help.feature5': 'Dictionary-based secret brute forcing',
            'help.feature6': 'Secure HMAC and RSA key generation',
            'help.feature7': 'Token signature validation and verification',
            'help.feature8': 'HTTP request testing with JWT tokens',
            'help.supported_algorithms': 'Supported Algorithms',
            'help.hmac_algorithms': 'HMAC Algorithms:',
            'help.rsa_algorithms': 'RSA Algorithms:',
            'help.ecdsa_algorithms': 'ECDSA Algorithms:',
            'help.pss_algorithms': 'PSS Algorithms:',
            'help.other_algorithms': 'Other:',
            'help.algorithm_notes': 'Algorithm Notes:',
            'help.algorithm_note1': 'HMAC algorithms use symmetric keys (shared secret)',
            'help.algorithm_note2': 'RSA algorithms use asymmetric keys (private/public key pairs)',
            'help.algorithm_note3': 'The "none" algorithm disables signature verification (dangerous!)',
            'help.algorithm_note4': 'Higher bit lengths (384, 512) provide stronger security',
            'help.algorithm_note5': 'ECDSA provides equivalent security with smaller key sizes',
            'help.algorithm_note6': 'PSS algorithms provide additional security through probabilistic signatures',
            'help.attack_vectors': 'Attack Vectors Guide',
            'help.algorithm_none_help': 'Algorithm None Attack:',
            'help.algorithm_none_desc': 'Removes signature verification by changing the algorithm to "none". Test if your application validates algorithms.',
            'help.algorithm_confusion_help': 'Algorithm Confusion:',
            'help.algorithm_confusion_desc': 'Changes RS256 to HS256, using the public key as an HMAC secret. Exploits applications that don\'t properly validate algorithm types.',
            'help.weak_secret_help': 'Weak Secret Attack:',
            'help.weak_secret_desc': 'Targets HMAC-signed JWTs with predictable secrets. Use dictionary attacks to discover weak passwords like "secret", "password", or "key".',
            'help.token_replay_help': 'Token Replay Attack:',
            'help.token_replay_desc': 'Exploits tokens without proper expiration or time-based claims. Removes exp, nbf, and iat claims to enable indefinite token reuse.',
            'help.jwk_injection_help': 'JWK Injection:',
            'help.jwk_injection_desc': 'Injects a malicious JWK (JSON Web Key) in the token header to bypass signature verification.',
            'help.kid_injection_help': 'Kid Parameter Injection:',
            'help.kid_injection_desc': 'Exploits the "kid" (Key ID) parameter for path traversal and injection attacks when applications use it unsafely.',
            'help.jku_hijack_help': 'JKU URL Hijacking:',
            'help.jku_hijack_desc': 'Points the "jku" parameter to attacker-controlled servers hosting malicious JWK sets for signature bypass.',
            'help.x5u_exploit_help': 'X5U Certificate Exploit:',
            'help.x5u_exploit_desc': 'Exploits the "x5u" parameter by pointing to malicious X.509 certificate chains, enabling signature bypass and SSRF attacks.',
            'help.jwt_smuggling_help': 'JWT Smuggling:',
            'help.jwt_smuggling_desc': 'Exploits parsing differences between JWT libraries to smuggle malicious tokens.',
            'help.nested_jwt_help': 'Nested JWT Attack:',
            'help.nested_jwt_desc': 'Places one JWT inside another\'s payload to exploit validation logic and achieve privilege escalation through token confusion.',
            'help.audience_confusion_help': 'Audience Confusion:',
            'help.audience_confusion_desc': 'Exploits weak audience claim validation to enable cross-service token reuse and privilege escalation.',
            'help.parameter_pollution_help': 'Parameter Pollution:',
            'help.parameter_pollution_desc': 'Uses duplicate JSON keys with conflicting values to exploit parsing differences between libraries.',
            'help.timing_attack_help': 'Timing Attack:',
            'help.timing_attack_desc': 'Analyzes signature verification timing to extract key material or bypass security through statistical timing analysis.',
            'help.jwt_sidejacking_help': 'JWT Sidejacking:',
            'help.jwt_sidejacking_desc': 'Targets JWT-specific session management vulnerabilities including token hijacking, fixation, and cross-site theft.',
            'help.jwks_poisoning_help': 'JWKS Cache Poisoning:',
            'help.jwks_poisoning_desc': 'Poisons JSON Web Key Set caches with malicious keys to compromise all applications using the poisoned cache.',
            'help.quantum_prep_help': 'Quantum-Prep Attack:',
            'help.quantum_prep_desc': 'Evaluates JWT resistance to future quantum computing attacks and recommends post-quantum cryptography migration.',
            'help.tools_guide': 'Tools Guide',
            'help.decoder_help': 'JWT Decoder:',
            'help.decoder_desc': 'Paste any JWT token to see its header, payload, and signature in human-readable format. Analyzes claims and provides token structure insights.',
            'help.encoder_help': 'JWT Encoder:',
            'help.encoder_desc': 'Create custom JWT tokens by specifying header, payload, algorithm, and secret. Supports templates for common token structures.',
            'help.security_help': 'Security Analysis:',
            'help.security_desc': 'Comprehensive vulnerability scanner that checks for common JWT security issues and provides a security score.',
            'help.bruteforce_help': 'Brute Force:',
            'help.bruteforce_desc': 'Test HMAC secret strength using dictionary attacks. Load common secrets or custom wordlists to crack weak tokens.',
            'help.keygen_help': 'Key Generator:',
            'help.keygen_desc': 'Generate cryptographically secure HMAC secrets and RSA key pairs for production use. Supports multiple key sizes.',
            'help.validator_help': 'Token Validator:',
            'help.validator_desc': 'Verify JWT token signatures and validate claims against provided secrets or public keys.',
            'help.http_tester_help': 'HTTP Tester:',
            'help.http_tester_desc': 'Test JWT tokens in real HTTP requests. Configure headers, body, and authorization to see how tokens behave in API calls.',
            'help.base64_tools_help': 'Base64 Tools:',
            'help.base64_tools_desc': 'Encode plain text to Base64 or decode Base64 strings back to plain text. Useful for manually crafting JWT components.',
            'help.about': 'About',
            'help.description': 'Comprehensive JWT security testing suite',
            'help.built_with': 'www.bavamont.com',
            'help.powered_by': 'Built for developers',
            'help.auto_updates': 'Updates with new attack vectors and features',
            'help.security_disclaimer_title': 'Security Disclaimer:',
            'help.security_disclaimer': 'This tool is designed for legitimate security testing and educational purposes only. Always ensure you have proper authorization before testing any system. Users are responsible for complying with applicable laws and regulations.',

            'updater.title': 'App Updater',
            'updater.checking': 'Checking for updates...',
            'updater.available': 'Update Available',
            'updater.not_available': 'You are using the latest version',
            'updater.downloading': 'Downloading update...',
            'updater.downloaded': 'Update downloaded. Restart to install.',
            'updater.error': 'Update failed',
            'updater.install_now': 'Install Now',
            'updater.install_later': 'Install Later',
            'updater.skip_version': 'Skip This Version',
            'updater.check_updates': 'Check for Updates',
            'updater.current_version': 'Current Version:',
            'updater.new_version': 'New Version:',
            'updater.release_notes': 'Release Notes',
            'updater.download_progress': 'Download Progress:',

            'common.browse': 'Browse',
            'common.ok': 'OK',
            'common.cancel': 'Cancel',
            'common.yes': 'Yes',
            'common.no': 'No',
            'common.apply': 'Apply',
            'common.reset': 'Reset',
            'common.default': 'Default',
            'common.copy': 'Copy',
            'common.save': 'Save',
            'common.load': 'Load',
            'common.export': 'Export',
            'common.import': 'Import',
            'common.delete': 'Delete',
            'common.edit': 'Edit',
            'common.view': 'View',
            'common.download': 'Download',
            'common.upload': 'Upload',
            'common.refresh': 'Refresh',
            'common.search': 'Search',
            'common.filter': 'Filter',
            'common.sort': 'Sort',
            'common.settings': 'Settings',
            'common.preferences': 'Preferences',
            'common.options': 'Options',
            'common.tools': 'Tools',
            'common.utilities': 'Utilities',
            'common.back': 'Back',
            'common.next': 'Next',
            'common.previous': 'Previous',
            'common.continue': 'Continue',
            'common.finish': 'Finish',
            'common.start': 'Start',
            'common.stop': 'Stop',
            'common.pause': 'Pause',
            'common.resume': 'Resume',
            'common.retry': 'Retry',
            'common.skip': 'Skip',
            'common.ignore': 'Ignore',
            'common.warning': 'Warning',
            'common.error': 'Error',
            'common.success': 'Success',
            'common.info': 'Information',
            'common.loading': 'Loading...',
            'common.processing': 'Processing...',
            'common.connecting': 'Connecting...',
            'common.disconnected': 'Disconnected',
            'common.connected': 'Connected',
            'common.online': 'Online',
            'common.offline': 'Offline',

            'toast.update_checking': 'Checking for updates...',
            'toast.update_available': 'Update available!',
            'toast.update_not_available': 'No updates available',
            'toast.update_downloaded': 'Update ready to install',
            'toast.update_error': 'Update check failed',
            'toast.invalid_token': 'Invalid JWT token format',
            'toast.provide_header_payload': 'Please provide both header and payload',
            'toast.hmac_secret_required': 'HMAC secret is required for this algorithm',
            'toast.rsa_key_required': 'RSA private key is required for this algorithm',
            'toast.ecdsa_key_required': 'ECDSA private key is required for this algorithm',
            'toast.token_generated': 'JWT token generated successfully',
            'toast.token_generation_failed': 'Token generation failed',
            'toast.provide_token_analyze': 'Please provide a JWT token to analyze',
            'toast.security_analysis_failed': 'Security analysis failed',
            'toast.provide_token_attack': 'Please provide a target JWT token',
            'toast.unknown_attack': 'Unknown attack type',
            'toast.attack_generation_failed': 'Attack generation failed',
            'toast.provide_token_crack': 'Please provide a JWT token to crack',
            'toast.provide_wordlist': 'Please provide a wordlist',
            'toast.wordlist_empty': 'Wordlist is empty',
            'toast.invalid_token_crack': 'Invalid JWT token for cracking',
            'toast.brute_force_complete': 'Brute force attack completed - no secret found',
            'toast.secret_cracked': 'Secret successfully cracked!',
            'toast.common_secrets_loaded': 'Common secrets loaded:',
            'toast.hmac_secret_generated': 'HMAC secret generated with',
            'toast.rsa_keys_generated': 'RSA key pair generated with',
            'toast.ecdsa_keys_generated': 'ECDSA key pair generated with',
            'toast.key_generation_failed': 'Key generation failed',
            'toast.provide_token_validate': 'Please provide a JWT token to validate',
            'toast.provide_secret_key': 'Please provide a secret or public key',
            'toast.token_validation_failed': 'Token validation failed',
            'toast.enter_url': 'Please enter a URL',
            'toast.request_failed': 'HTTP request failed',
            'toast.request_config_error': 'Request configuration error',
            'toast.enter_text_encode': 'Please enter text to encode',
            'toast.text_encoded': 'Text encoded to Base64',
            'toast.enter_base64_decode': 'Please enter Base64 string to decode',
            'toast.base64_decoded': 'Base64 decoded successfully',
            'toast.invalid_base64': 'Invalid Base64 string',
            'toast.copied_clipboard': 'Copied to clipboard',
            'toast.copy_failed': 'Copy failed',
            'toast.copy_not_supported': 'Clipboard not supported',
            'toast.file_loaded': 'File loaded with',
            'toast.file_load_failed': 'File load failed',
            'toast.file_load_error': 'File load error',
            'toast.no_token_data': 'No token data available',
            'toast.token_sent_encoder': 'Token data sent to encoder',
            'toast.secret_loaded_encoder': 'Secret loaded in encoder',
            'toast.detailed_scan_complete': 'Detailed security scan completed',

            'claims.issuer': 'Issuer',
            'claims.subject': 'Subject',
            'claims.audience': 'Audience',
            'claims.expiration': 'Expiration Time',
            'claims.not_before': 'Not Before',
            'claims.issued_at': 'Issued At',
            'claims.jwt_id': 'JWT ID',
            'claims.scope': 'Scope',
            'claims.roles': 'Roles',
            'claims.permissions': 'Permissions',
            'claims.nonce': 'Nonce',
            'claims.authorized_party': 'Authorized Party',
            'claims.at_hash': 'Access Token Hash',
            'claims.c_hash': 'Code Hash',
            'claims.issuer_desc': 'The principal that issued the JWT',
            'claims.subject_desc': 'The principal that is the subject of the JWT',
            'claims.audience_desc': 'The recipients that the JWT is intended for',
            'claims.expiration_desc': 'The expiration time on or after which the JWT MUST NOT be accepted',
            'claims.not_before_desc': 'The time before which the JWT MUST NOT be accepted',
            'claims.issued_at_desc': 'The time at which the JWT was issued',
            'claims.jwt_id_desc': 'A unique identifier for the JWT',
            'claims.scope_desc': 'Space-delimited list of scopes associated with the token',
            'claims.roles_desc': 'User roles or groups',
            'claims.permissions_desc': 'Specific permissions granted to the token',
            'claims.nonce_desc': 'String value used to associate a client session with an ID token',
            'claims.authorized_party_desc': 'The party to which the ID token was issued',
            'claims.at_hash_desc': 'Access token hash value',
            'claims.c_hash_desc': 'Code hash value',

            'vulns.algorithm_none': 'Algorithm "none" Vulnerability',
            'vulns.algorithm_none_desc': 'Token uses the "none" algorithm which disables signature verification',
            'vulns.algorithm_none_impact': 'Complete authentication bypass - anyone can create valid tokens',
            'vulns.algorithm_none_rec': 'Never use the "none" algorithm in production environments',
            'vulns.weak_algorithm': 'Weak Algorithm',
            'vulns.weak_algorithm_desc': 'Token uses HS256 which may be vulnerable to brute force attacks with weak secrets',
            'vulns.weak_algorithm_impact': 'Potential secret compromise through dictionary attacks',
            'vulns.weak_algorithm_rec': 'Use stronger algorithms like HS384/HS512 or RSA-based algorithms',
            'vulns.missing_algorithm': 'Missing Algorithm',
            'vulns.missing_algorithm_desc': 'Token header does not specify an algorithm',
            'vulns.missing_algorithm_impact': 'Undefined behavior - may default to insecure algorithms',
            'vulns.missing_algorithm_rec': 'Always explicitly specify the algorithm in the token header',
            'vulns.missing_expiration': 'Missing Expiration Claim',
            'vulns.missing_expiration_desc': 'Token does not have an expiration time (exp claim)',
            'vulns.missing_expiration_impact': 'Tokens never expire, allowing unlimited reuse',
            'vulns.missing_expiration_rec': 'Always include an expiration time in tokens',
            'vulns.expired_token': 'Expired Token',
            'vulns.expired_token_desc': 'Token has exceeded its expiration time',
            'vulns.expired_token_impact': 'Token should not be accepted by applications',
            'vulns.expired_token_rec': 'Ensure applications properly validate expiration times',
            'vulns.missing_issued_at': 'Missing Issued At Claim',
            'vulns.missing_issued_at_desc': 'Token does not specify when it was issued (iat claim)',
            'vulns.missing_issued_at_impact': 'Difficult to track token age and implement time-based policies',
            'vulns.missing_issued_at_rec': 'Include the "iat" (issued at) claim in tokens',
            'vulns.missing_issuer': 'Missing Issuer Claim',
            'vulns.missing_issuer_desc': 'Token does not specify who issued it (iss claim)',
            'vulns.missing_issuer_impact': 'Cannot verify token origin or implement issuer-based validation',
            'vulns.missing_issuer_rec': 'Include the "iss" (issuer) claim to identify token source',
            'vulns.admin_token': 'Administrative Token',
            'vulns.admin_token_desc': 'Token contains administrative privileges (subject is "admin")',
            'vulns.admin_token_impact': 'High-privilege token that could cause significant damage if compromised',
            'vulns.admin_token_rec': 'Use role-based access control instead of subject-based admin detection',
            'vulns.malformed_token': 'Malformed Token',
            'vulns.malformed_token_desc': 'Token does not have the correct three-part structure',
            'vulns.malformed_token_impact': 'Token cannot be properly validated',
            'vulns.malformed_token_rec': 'Ensure tokens follow the proper JWT format (header.payload.signature)',
            'vulns.missing_signature': 'Missing Signature',
            'vulns.missing_signature_desc': 'Token has an empty signature component',
            'vulns.missing_signature_impact': 'Token cannot be verified for authenticity',
            'vulns.missing_signature_rec': 'Ensure tokens are properly signed with a secure algorithm',
            'vulns.large_token': 'Oversized Token',
            'vulns.large_token_desc': 'Token exceeds recommended size limits',
            'vulns.large_token_impact': 'May cause performance issues or exceed HTTP header limits',
            'vulns.large_token_rec': 'Keep tokens under 8KB and minimize payload size',
            'vulns.invalid_base64': 'Invalid Base64 Encoding',
            'vulns.invalid_base64_desc': 'Token parts contain invalid Base64URL encoding',
            'vulns.invalid_base64_impact': 'Token may not be processed correctly by all JWT libraries',
            'vulns.invalid_base64_rec': 'Ensure proper Base64URL encoding without padding',
            'vulns.jwk_injection': 'JWK Injection Vulnerability',
            'vulns.jwk_injection_desc': 'Token header contains a JWK (JSON Web Key) which could be malicious',
            'vulns.jwk_injection_impact': 'Attacker can control the verification key, bypassing signature validation',
            'vulns.jwk_injection_rec': 'Never trust JWKs embedded in token headers - use a trusted key store',
            'vulns.kid_path_traversal': 'Key ID Path Traversal',
            'vulns.kid_path_traversal_desc': 'The "kid" parameter contains path traversal sequences',
            'vulns.kid_path_traversal_impact': 'Potential file system access or unauthorized key loading',
            'vulns.kid_path_traversal_rec': 'Validate and sanitize the "kid" parameter against a whitelist',
            'vulns.kid_sql_injection': 'Key ID SQL Injection',
            'vulns.kid_sql_injection_desc': 'The "kid" parameter contains potential SQL injection payloads',
            'vulns.kid_sql_injection_impact': 'Database compromise if kid is used in SQL queries',
            'vulns.kid_sql_injection_rec': 'Use parameterized queries and validate kid values',
            'vulns.jku_hijacking': 'JKU URL Hijacking',
            'vulns.jku_hijacking_desc': 'Token header contains a "jku" parameter pointing to an external URL',
            'vulns.jku_hijacking_impact': 'Attacker can host malicious JWK sets to bypass verification',
            'vulns.jku_hijacking_rec': 'Only allow trusted JKU URLs or disable JKU processing entirely',
            'vulns.x5u_exploit': 'X5U Certificate Exploit',
            'vulns.x5u_exploit_desc': 'Token header contains an "x5u" parameter for X.509 certificate chain',
            'vulns.x5u_exploit_impact': 'Attacker can provide malicious certificate chains',
            'vulns.x5u_exploit_rec': 'Validate certificate chains against trusted CAs and implement URL restrictions',
            'vulns.multi_audience': 'Multiple Audience Vulnerability',
            'vulns.multi_audience_desc': 'Token has multiple audiences which may cause confusion',
            'vulns.multi_audience_impact': 'Token reuse across services that should not accept it',
            'vulns.multi_audience_rec': 'Use service-specific tokens with single audience values',
            'vulns.nested_jwt': 'Nested JWT Detected',
            'vulns.nested_jwt_desc': 'Token contains another JWT in its payload',
            'vulns.nested_jwt_impact': 'Complex validation logic may lead to privilege escalation',
            'vulns.nested_jwt_rec': 'Avoid nested JWTs or implement careful validation of inner tokens',
            'vulns.quantum_vulnerable': 'Quantum-Vulnerable Algorithm',
            'vulns.quantum_vulnerable_desc': 'Token uses an algorithm vulnerable to quantum computing attacks',
            'vulns.quantum_vulnerable_impact': 'Future cryptographic compromise when quantum computers are available',
            'vulns.quantum_vulnerable_rec': 'Plan migration to post-quantum cryptography algorithms'
        },
        de: {
            'app.title': 'JWT Security Analyzer',
            'app.subtitle': 'JWT Token-Analyse & Sicherheitstestsuite',

            'window.minimize': 'Minimieren',
            'window.maximize': 'Maximieren',
            'window.restore': 'Wiederherstellen',
            'window.close': 'Schließen',

            'nav.decoder': 'JWT Decoder',
            'nav.decoder.tooltip': 'JWT-Token dekodieren und analysieren',
            'nav.encoder': 'JWT Encoder',
            'nav.encoder.tooltip': 'Benutzerdefinierte JWT-Token erstellen',
            'nav.security': 'Sicherheitsanalyse',
            'nav.security.tooltip': 'Schwachstellenerkennung und -analyse',
            'nav.attacks': 'Angriffsvektoren',
            'nav.attacks.tooltip': 'Angriffs-Payloads generieren',
            'nav.bruteforce': 'Brute Force',
            'nav.bruteforce.tooltip': 'Schwache Geheimnisse knacken',
            'nav.keygen': 'Schlüsselgenerator',
            'nav.keygen.tooltip': 'RSA/HMAC-Schlüssel generieren',
            'nav.validator': 'Token-Validator',
            'nav.validator.tooltip': 'Token-Integrität verifizieren',
            'nav.utilities': 'DIENSTPROGRAMME',
            'nav.http_tester': 'HTTP-Tester',
            'nav.http_tester.tooltip': 'JWT-Token in Anfragen testen',
            'nav.base64': 'Base64-Tools',
            'nav.base64.tooltip': 'Base64 kodieren/dekodieren',
            'nav.help': 'Hilfe',
            'nav.help.tooltip': 'Benutzerhandbuch und Dokumentation',

            'decoder.title': 'JWT Token Decoder',
            'decoder.subtitle': 'JWT-Token dekodieren und analysieren, um ihre Struktur und Claims anzuzeigen',
            'decoder.token_input': 'JWT Token Eingabe',
            'decoder.jwt_token': 'JWT Token',
            'decoder.jwt_placeholder': 'JWT-Token hier einfügen...',
            'decoder.input_help': 'Vollständigen JWT-Token einfügen (header.payload.signature)',
            'decoder.decode_token': 'Token Dekodieren',
            'decoder.clear': 'Löschen',
            'decoder.load_example': 'Beispiel Laden',
            'decoder.token_structure': 'Token-Struktur',
            'decoder.valid': 'Gültig',
            'decoder.invalid': 'Ungültig',
            'decoder.send_to_encoder': 'An Encoder Senden',
            'decoder.header': 'Header',
            'decoder.payload': 'Payload',
            'decoder.signature': 'Signatur',
            'decoder.copy': 'Kopieren',
            'decoder.base64_encoded': 'Base64 Kodiert:',
            'decoder.decoded_json': 'Dekodiertes JSON:',
            'decoder.algorithm': 'Algorithmus:',
            'decoder.length': 'Länge:',
            'decoder.status': 'Status:',
            'decoder.unknown': 'Unbekannt',
            'decoder.claims_analysis': 'Claims-Analyse',
            'decoder.no_signature': 'Keine Signatur',
            'decoder.missing': 'Fehlend',
            'decoder.present': 'Vorhanden',

            'encoder.title': 'JWT Token Encoder',
            'encoder.subtitle': 'Benutzerdefinierte JWT-Token mit beliebigem Header, Payload und Signatur erstellen',
            'encoder.token_config': 'Token-Konfiguration',
            'encoder.header': 'Header',
            'encoder.payload': 'Payload',
            'encoder.header_placeholder': '{\n  "alg": "HS256",\n  "typ": "JWT"\n}',
            'encoder.payload_placeholder': '{\n  "sub": "1234567890",\n  "name": "John Doe",\n  "iat": 1516239022\n}',
            'encoder.algorithm': 'Algorithmus',
            'encoder.hs256': 'HS256 (HMAC SHA-256)',
            'encoder.hs384': 'HS384 (HMAC SHA-384)',
            'encoder.hs512': 'HS512 (HMAC SHA-512)',
            'encoder.rs256': 'RS256 (RSA SHA-256)',
            'encoder.rs384': 'RS384 (RSA SHA-384)',
            'encoder.rs512': 'RS512 (RSA SHA-512)',
            'encoder.es256': 'ES256 (ECDSA SHA-256)',
            'encoder.es384': 'ES384 (ECDSA SHA-384)',
            'encoder.es512': 'ES512 (ECDSA SHA-512)',
            'encoder.ps256': 'PS256 (RSASSA-PSS SHA-256)',
            'encoder.ps384': 'PS384 (RSASSA-PSS SHA-384)',
            'encoder.ps512': 'PS512 (RSASSA-PSS SHA-512)',
            'encoder.none': 'none (Keine Signatur)',
            'encoder.secret_key': 'Geheimnis/Privater Schlüssel',
            'encoder.secret_placeholder': 'Geheimnis oder privaten Schlüssel eingeben...',
            'encoder.secret_help': 'Für HMAC: Geheimnis-String eingeben. Für RSA: Privaten Schlüssel im PEM-Format eingeben.',
            'encoder.generate_token': 'Token Generieren',
            'encoder.clear_all': 'Alle Löschen',
            'encoder.load_template': 'Vorlage Laden',
            'encoder.generated_token': 'Generierter Token',
            'encoder.copy_token': 'Token Kopieren',
            'encoder.test_token': 'Token Testen',

            'security.title': 'Sicherheitsanalyse',
            'security.subtitle': 'Umfassende Schwachstellenanalyse für JWT-Token',
            'security.token_scanner': 'Token-Sicherheitsscanner',
            'security.jwt_to_analyze': 'Zu analysierender JWT-Token',
            'security.jwt_placeholder': 'JWT-Token für Sicherheitsanalyse einfügen...',
            'security.analyze_security': 'Sicherheit Analysieren',
            'security.security_assessment': 'Sicherheitsbewertung',
            'security.security_score': 'Sicherheitsbewertung:',
            'security.critical': 'Kritisch',
            'security.high': 'Hoch',
            'security.medium': 'Mittel',
            'security.low': 'Niedrig',
            'security.info': 'Info',

            'attacks.title': 'Angriffsvektoren',
            'attacks.subtitle': 'Angriffs-Payloads für häufige JWT-Schwachstellen generieren',
            'attacks.attack_generator': 'Angriffsgenerator',
            'attacks.target_jwt': 'Ziel-JWT-Token',
            'attacks.target_placeholder': 'Ziel-JWT-Token hier einfügen...',
            'attacks.attacks': 'Angriffe',
            'attacks.generate_attack': 'Angriff Generieren',
            'attacks.generated_payloads': 'Generierte Angriffs-Payloads',

            'attacks.none': 'Algorithmus None',
            'attacks.confusion': 'Algorithmus-Verwirrung',
            'attacks.replay': 'Token-Wiederholung',
            'attacks.weak-secret': 'Schwaches Geheimnis',
            'attacks.jwk-injection': 'JWK-Injektion',
            'attacks.kid-injection': 'Kid-Parameter-Injektion',
            'attacks.jku-hijack': 'JKU-URL-Entführung',
            'attacks.x5u-exploit': 'X5U-Zertifikat-Exploit',
            'attacks.jwt-smuggling': 'JWT-Schmuggel',
            'attacks.nested-jwt': 'Verschachtelter JWT-Angriff',
            'attacks.audience-confusion': 'Zielgruppen-Verwirrung',
            'attacks.parameter-pollution': 'Parameter-Verschmutzung',
            'attacks.timing-attack': 'Timing-Angriff',
            'attacks.jwt-sidejacking': 'JWT-Sidejacking',
            'attacks.jwks-poisoning': 'JWKS-Cache-Vergiftung',
            'attacks.quantum-prep': 'Quantum-Prep-Angriff',

            'attacks.algorithm_none': 'Algorithmus None',
            'attacks.algorithm_none_desc': 'Signaturverifizierung durch Setzen des Algorithmus auf "none" entfernen',
            'attacks.algorithm_confusion': 'Algorithmus-Verwirrung',
            'attacks.algorithm_confusion_desc': 'RS256 zu HS256 ändern und öffentlichen Schlüssel als HMAC-Geheimnis verwenden',
            'attacks.weak_secret': 'Schwaches Geheimnis',
            'attacks.weak_secret_desc': 'Schwache HMAC-Geheimnisse mit Wörterbuchangriffen ausnutzen',
            'attacks.token_replay': 'Token-Wiederholung',
            'attacks.token_replay_desc': 'Token in verschiedenen Sitzungen oder Umgebungen wiederverwenden',
            'attacks.jwk_injection': 'JWK-Injektion',
            'attacks.jwk_injection_desc': 'Bösartigen JWK in Header injizieren, um Signaturverifizierung zu umgehen',
            'attacks.kid_injection': 'Kid-Parameter-Injektion',
            'attacks.kid_injection_desc': 'Pfad-Traversal und Injektion über den "kid"-Header-Parameter',
            'attacks.jku_hijack': 'JKU-URL-Entführung',
            'attacks.jku_hijack_desc': 'JKU auf angreifer-kontrollierten JWK-Satz zeigen lassen',
            'attacks.x5u_exploit': 'X5U-Zertifikat-Exploit',
            'attacks.x5u_exploit_desc': 'X.509-Zertifikat-URL-Parameter ausnutzen',
            'attacks.jwt_smuggling': 'JWT-Schmuggel',
            'attacks.jwt_smuggling_desc': 'Parsing-Unterschiede zwischen JWT-Bibliotheken ausnutzen',
            'attacks.nested_jwt': 'Verschachtelter JWT-Angriff',
            'attacks.nested_jwt_desc': 'JWT-in-JWT-Verwirrung und Berechtigungseskalation',
            'attacks.audience_confusion': 'Zielgruppen-Verwirrung',
            'attacks.audience_confusion_desc': 'Multi-Audience-Token-Wiederverwendung zwischen Diensten',
            'attacks.parameter_pollution': 'Parameter-Verschmutzung',
            'attacks.parameter_pollution_desc': 'Doppelte Parameter mit widersprüchlichen Werten',
            'attacks.timing_attack': 'Timing-Angriff',
            'attacks.timing_attack_desc': 'Zeitunterschiede bei der Signaturverifizierung ausnutzen',
            'attacks.jwt_sidejacking': 'JWT-Sidejacking',
            'attacks.jwt_sidejacking_desc': 'Session-Hijacking spezifisch für JWT-Implementierungen',
            'attacks.jwks_poisoning': 'JWKS-Cache-Vergiftung',
            'attacks.jwks_poisoning_desc': 'JWKS-Cache mit bösartigen Schlüsseln vergiften',
            'attacks.quantum_prep': 'Quantum-Prep-Angriff',
            'attacks.quantum_prep_desc': 'Quantum-anfällige Algorithmen und Schlüsselgrößen testen',

            'attacks.none_title': 'Algorithmus-None-Angriff Erklärt',
            'attacks.confusion_title': 'Algorithmus-Verwirrungsangriff Erklärt',
            'attacks.weak_secret_title': 'Schwache-Geheimnis-Angriff Erklärt',
            'attacks.replay_title': 'Token-Replay-Angriff Erklärt',
            'attacks.jwk_injection_title': 'JWK-Injektionsangriff Erklärt',
            'attacks.kid_injection_title': 'Kid-Parameter-Injektionsangriff Erklärt',
            'attacks.jku_hijack_title': 'JKU-URL-Entführungsangriff Erklärt',
            'attacks.x5u_exploit_title': 'X5U-Zertifikat-Exploit Erklärt',
            'attacks.jwt_smuggling_title': 'JWT-Schmuggelangriff Erklärt',
            'attacks.nested_jwt_title': 'Verschachtelter JWT-Angriff Erklärt',
            'attacks.audience_confusion_title': 'Zielgruppen-Verwirrungsangriff Erklärt',
            'attacks.parameter_pollution_title': 'Parameter-Verschmutzungsangriff Erklärt',
            'attacks.timing_attack_title': 'Timing-Angriff Erklärt',
            'attacks.jwt_sidejacking_title': 'JWT-Sidejacking-Angriff Erklärt',
            'attacks.jwks_poisoning_title': 'JWKS-Cache-Vergiftungsangriff Erklärt',
            'attacks.quantum_prep_title': 'Quantum-Prep-Angriff Erklärt',

            'attacks.how_none_works': 'Der "none"-Algorithmus-Angriff funktioniert durch Änderung des Algorithmus-Feldes im JWT-Header von einem sicheren Signaturalgorithmus (wie HS256 oder RS256) zu "none". Dies teilt dem Server mit, die Signaturverifizierung vollständig zu überspringen. Der Server verarbeitet den Token als gültig, ohne zu prüfen, ob er tatsächlich vom legitimen Aussteller signiert wurde. Angreifer können jeden Teil der Payload ändern (wie das Ändern von Benutzerrollen von "user" zu "admin") und die Anwendung wird es als authentisch akzeptieren.',

            'attacks.how_confusion_works': 'Algorithmus-Verwirrung nutzt Anwendungen aus, die sowohl RSA (asymmetrisch) als auch HMAC (symmetrisch) Algorithmen verwenden. Bei RSA werden Token mit einem privaten Schlüssel signiert und mit einem öffentlichen Schlüssel verifiziert. Bei HMAC wird das gleiche Geheimnis sowohl zum Signieren als auch zur Verifizierung verwendet. Der Angriff funktioniert durch: 1) Erlangen des RSA-öffentlichen Schlüssels (oft öffentlich verfügbar), 2) Ändern des Token-Algorithmus von RS256 zu HS256, 3) Verwenden des öffentlichen Schlüssels als HMAC-Geheimnis zum Signieren des modifizierten Tokens. Der Server, der konfiguriert ist, den öffentlichen Schlüssel zur Verifizierung zu verwenden, validiert unwissentlich die Signatur des Angreifers.',

            'attacks.how_weak_secret_works': 'Schwache-Geheimnis-Angriffe zielen auf HMAC-signierte JWTs ab, die vorhersagbare oder gebräuchliche Geheimnisse wie "secret", "password" oder "key" verwenden. Da HMAC symmetrische Verschlüsselung verwendet, kann ein Angreifer, wenn er das Geheimnis erraten kann, gültige Token fälschen. Der Angriff umfasst: 1) Nehmen eines legitimen JWT, 2) Ausprobieren gebräuchlicher Passwörter aus Wortlisten, 3) Versuchen, die Signatur mit jedem Passwort zu recreieren, 4) Wenn die Signatur übereinstimmt, wurde das Geheimnis entdeckt und kann verwendet werden, um beliebige gültige Token zu erstellen.',

            'attacks.how_replay_works': 'Token-Replay-Angriffe nutzen JWTs aus, denen ordnungsgemäße zeitbasierte Beschränkungen fehlen. Durch Entfernen oder Ändern von Claims wie "exp" (Ablauf), "nbf" (nicht vor) und "iat" (ausgestellt am) können Angreifer Token unbegrenzt wiederverwenden. Der Angriff funktioniert durch: 1) Abfangen eines gültigen JWT, 2) Entfernen zeitbasierter Claims aus der Payload, 3) Beibehalten der ursprünglichen Signatur, 4) Wiederverwenden des Tokens über verschiedene Sitzungen, Zeiten oder sogar verschiedene Benutzer hinweg, wenn die Anwendung den Token-Kontext nicht ordnungsgemäß validiert.',

            'attacks.how_jwk_injection_works': 'JWK-Injektion nutzt den "jwk"-Header-Parameter aus, der das direkte Einbetten eines öffentlichen Schlüssels in den JWT-Header ermöglicht. Wenn Server diesem eingebetteten Schlüssel zur Verifizierung vertrauen, können Angreifer: 1) Ihr eigenes RSA-Schlüsselpaar generieren, 2) Ihren öffentlichen Schlüssel im JWT-Header mit dem "jwk"-Parameter einbetten, 3) Den Token mit ihrem privaten Schlüssel signieren, 4) Die Payload nach Wunsch ändern. Der Server verwendet den eingebetteten öffentlichen Schlüssel des Angreifers zur Signaturverifizierung, wodurch der bösartige Token gültig erscheint.',

            'attacks.how_kid_injection_works': 'Der "kid" (Key ID) Parameter teilt dem Server mit, welcher Schlüssel zur Verifizierung verwendet werden soll. Anwendungen verwenden diesen Wert oft in Dateioperationen oder Datenbankabfragen ohne ordnungsgemäße Bereinigung. Angriffsvektoren umfassen: 1) Pfad-Traversal: "../../../etc/passwd" zum Zugriff auf sensible Dateien, 2) SQL-Injektion: "\' OR \'1\'=\'1" zur Manipulation von Datenbankabfragen, 3) Befehlsinjektion: "key; rm -rf /" zur Ausführung von Systembefehlen, 4) Verzeichnis-Traversal zum Laden beliebiger Dateien als Verifizierungsschlüssel.',

            'attacks.how_jku_hijack_works': 'JKU (JSON Web Key Set URL) Entführung nutzt den "jku"-Parameter aus, der auf eine URL mit öffentlichen Schlüsseln zur Verifizierung zeigt. Angreifer können: 1) Die "jku"-URL ändern, um auf ihren kontrollierten Server zu zeigen, 2) Ihre eigenen JWKS mit bösartigen öffentlichen Schlüsseln hosten, 3) Token mit den entsprechenden privaten Schlüsseln signieren, 4) Die Anwendung ruft Schlüssel von der Angreifer-URL ab und verwendet sie zur Verifizierung. Dies kann auch zu SSRF (Server-Side Request Forgery) Schwachstellen führen.',

            'attacks.how_x5u_exploit_works': 'Der "x5u"-Parameter spezifiziert eine URL für X.509-Zertifikatsketten, die bei der Token-Verifizierung verwendet werden. Ähnlich wie JKU-Angriffe können Angreifer: 1) "x5u" auf ihren bösartigen Zertifikatsserver zeigen lassen, 2) Gefälschte Zertifikatsketten erstellen, 3) Token mit entsprechenden privaten Schlüsseln signieren, 4) Die Anwendung lädt die bösartigen Zertifikate herunter und vertraut ihnen. Dieser Angriff kann auch Zertifikat-Parsing-Schwachstellen ausnutzen und SSRF-Angriffe ermöglichen.',

            'attacks.how_jwt_smuggling_works': 'JWT-Schmuggel nutzt Unterschiede aus, wie verschiedene JWT-Bibliotheken Token parsen. Techniken umfassen: 1) Doppelte Header: Hinzufügen mehrerer Header-Abschnitte, die verschiedene Bibliotheken unterschiedlich interpretieren, 2) Eingebettete JWTs: Platzieren vollständiger JWTs in Payload-Feldern, 3) Fehlgeformte Strukturen: Verwendung ungewöhnlicher Formatierung, die Parsing-Inkonsistenzen verursacht, 4) Zeichenkodierungs-Tricks: Ausnutzen von Unicode- oder Kodierungsunterschieden. Eine Bibliothek könnte den äußeren Token validieren, während eine andere einen inneren bösartigen Token verarbeitet.',

            'attacks.how_nested_jwt_works': 'Verschachtelte JWT-Angriffe platzieren einen JWT innerhalb der Payload eines anderen JWT. Dies kann Verwirrung in Anwendungen verursachen, die mehrere Token-Ebenen verarbeiten: 1) Der äußere JWT wird normal validiert, 2) Die Anwendung extrahiert und verarbeitet einen inneren JWT aus der Payload, 3) Der innere JWT könnte verschiedene Claims haben (wie erhöhte Privilegien), 4) Wenn die Anwendung den Kontext des inneren Tokens nicht ordnungsgemäß validiert, könnte sie unbeabsichtigten Zugriff basierend auf den Claims des verschachtelten Tokens gewähren.',

            'attacks.how_audience_confusion_works': 'Zielgruppen-Verwirrung nutzt schwache Validierung des "aud" (Audience) Claims aus, der spezifiziert, welche Dienste den Token akzeptieren sollten. Angriffe umfassen: 1) Multi-Audience-Token: Erstellen von Token, die für mehrere Dienste gültig sind, 2) Fehlende Audience-Validierung: Token ohne "aud"-Claims werden überall akzeptiert, 3) Wildcard-Audiences: Verwendung von "*" oder leeren Strings als Audience-Werte, 4) Cross-Service-Token-Wiederverwendung: Verwendung von Token, die für einen Dienst bestimmt sind, um auf einen anderen zuzugreifen. Dies ermöglicht Privilegieneskalation über verschiedene Anwendungskomponenten hinweg.',

            'attacks.how_parameter_pollution_works': 'Parameter-Verschmutzung nutzt JSON-Parser aus, die doppelte Schlüssel unterschiedlich handhaben. Einige Parser verwenden das erste Vorkommen, andere das letzte. Beispiele: 1) {"alg":"HS256","alg":"none"} - erster Parser sieht HS256, zweiter sieht none, 2) {"sub":"user","sub":"admin"} - erstellt widersprüchliche Identitäts-Claims, 3) Verschiedene Bibliotheken, die das gleiche fehlgeformte JSON unterschiedlich handhaben, können zu Sicherheitsumgehungen führen, bei denen die Validierung einen Wert verwendet, aber die Autorisierung einen anderen.',

            'attacks.how_timing_attack_works': 'Timing-Angriffe nutzen messbare Unterschiede in der Signaturverifizierungszeit aus. Durch Senden vieler Token mit verschiedenen Signaturen und Messen der Antwortzeiten können Angreifer: 1) Gültige vs. ungültige Signaturen basierend auf der Verarbeitungszeit erkennen, 2) Gültige Signaturen durch Analyse von Timing-Mustern schrittweise rekonstruieren, 3) Rate-Limiting umgehen, indem sie identifizieren, welche Signaturen längere Verarbeitung verursachen, 4) Informationen über das Schlüsselmaterial des Servers durch statistische Analyse der Antwortzeiten extrahieren.',

            'attacks.how_jwt_sidejacking_works': 'JWT-Sidejacking zielt auf Session-Management-Schwachstellen spezifisch für JWT-Implementierungen ab: 1) Session-Fixierung: Benutzer zwingen, angreifer-kontrollierte JTIs (JWT IDs) zu verwenden, 2) Token-Hijacking: Stehlen von JWTs aus unsicherer Speicherung oder Übertragung, 3) Cross-Site-Token-Diebstahl: Verwendung von XSS zum Stehlen von JWTs aus Client-Speicher, 4) Netzwerk-Abfangen: Erfassen von JWTs aus unverschlüsselten Verbindungen, 5) Langlebige Token: Ausnutzen von JWTs ohne ordnungsgemäße Ablaufzeit für persistenten Zugriff.',

            'attacks.how_jwks_poisoning_works': 'JWKS-Cache-Vergiftung zielt auf Anwendungen ab, die JSON Web Key Sets aus Leistungsgründen zwischenspeichern. Angreifer können: 1) Cache-Updates mit bösartigen JWKS-Daten erzwingen, 2) Cache-Timing ausnutzen, um bösartige Schlüssel zu injizieren, 3) Cache-Verschmutzungstechniken verwenden, um legitime Schlüssel zu ersetzen, 4) TTL (Time To Live) Manipulation nutzen, um die Lebensdauer bösartiger Schlüssel zu verlängern, 5) Geteilte Caches vergiften, die mehrere Anwendungen betreffen. Einmal vergiftet, verwenden alle gegen den Cache verifizierten Token angreifer-kontrollierte Schlüssel.',

            'attacks.how_quantum_prep_works': 'Quantum-Bereitschaftstests bewerten die JWT-Resistenz gegen zukünftige Quantencomputing-Angriffe. Aktuelle RSA- und ECDSA-Algorithmen werden anfällig, wenn großskalige Quantencomputer existieren. Die Bewertung: 1) Identifiziert quantum-anfällige Algorithmen (RSA, ECDSA), 2) Schätzt die Knackzeit (2030-2040 für RSA-2048), 3) Testet Schlüsselgrößen und ihre Quantum-Resistenz, 4) Empfiehlt Migration zu Post-Quantum-Kryptographie-Algorithmen wie CRYSTALS-Dilithium, FALCON oder SPHINCS+.',

            'modal.attack_explanation': 'Angriffserklärung',
            'modal.close': 'Schließen',
            'modal.how_it_works': 'So funktioniert es',
            'modal.cancel': 'Abbrechen',
            'modal.confirm': 'Bestätigen',
            'modal.ok': 'OK',

            'bruteforce.title': 'Geheimnis Brute Force',
            'bruteforce.subtitle': 'Schwache HMAC-Geheimnisse mit Wörterbuchangriffen knacken',
            'bruteforce.config': 'Brute-Force-Konfiguration',
            'bruteforce.target_token': 'Ziel-Token',
            'bruteforce.token_placeholder': 'JWT-Token mit HMAC-Signatur einfügen...',
            'bruteforce.secret_wordlist': 'Geheimnis-Wörterliste',
            'bruteforce.wordlist_placeholder': 'Zu testende Geheimnisse eingeben, eines pro Zeile...',
            'bruteforce.load_common': 'Häufige Geheimnisse Laden',
            'bruteforce.load_file': 'Datei Laden',
            'bruteforce.start': 'Brute Force Starten',
            'bruteforce.stop': 'Stoppen',
            'bruteforce.in_progress': 'Brute Force läuft',
            'bruteforce.testing_secrets': 'Teste Geheimnisse...',
            'bruteforce.current': 'Aktuell:',
            'bruteforce.tested': 'Getestet:',
            'bruteforce.remaining': 'Verbleibend:',
            'bruteforce.speed': 'Geschwindigkeit:',
            'bruteforce.secret_cracked': 'Geheimnis Geknackt!',
            'bruteforce.discovered_secret': 'Entdecktes Geheimnis:',
            'bruteforce.copy': 'Kopieren',
            'bruteforce.use_in_encoder': 'Im Encoder Verwenden',
            'bruteforce.generate_new_tokens': 'Neue Token Generieren',

            'keygen.title': 'Schlüsselgenerator',
            'keygen.subtitle': 'Sichere Schlüssel für JWT-Token-Signierung generieren',
            'keygen.key_generation': 'Schlüsselgenerierung',
            'keygen.hmac_secrets': 'HMAC-Geheimnisse',
            'keygen.secret_length': 'Geheimnislänge:',
            'keygen.256_bit': '256-bit (32 Bytes)',
            'keygen.384_bit': '384-bit (48 Bytes)',
            'keygen.512_bit': '512-bit (64 Bytes)',
            'keygen.generate_hmac': 'HMAC-Geheimnis Generieren',
            'keygen.generated_secret': 'Generiertes Geheimnis:',
            'keygen.copy': 'Kopieren',
            'keygen.rsa_keypairs': 'RSA-Schlüsselpaare',
            'keygen.key_size': 'Schlüsselgröße:',
            'keygen.2048_bit': '2048-bit',
            'keygen.3072_bit': '3072-bit',
            'keygen.4096_bit': '4096-bit',
            'keygen.generate_rsa': 'RSA-Schlüssel Generieren',
            'keygen.private_key': 'Privater Schlüssel:',
            'keygen.public_key': 'Öffentlicher Schlüssel:',

            'validator.title': 'Token-Validator',
            'validator.subtitle': 'JWT-Token-Signaturen verifizieren und Claims validieren',
            'validator.token_validation': 'Token-Validierung',
            'validator.jwt_token': 'JWT-Token',
            'validator.token_placeholder': 'Zu validierenden JWT-Token einfügen...',
            'validator.secret_key': 'Geheimnis/Öffentlicher Schlüssel',
            'validator.key_placeholder': 'Geheimnis oder öffentlichen Schlüssel eingeben...',
            'validator.validate_token': 'Token Validieren',
            'validator.signature_only': 'Nur Signatur',
            'validator.validation_results': 'Validierungsergebnisse',

            'http.title': 'HTTP-Tester',
            'http.subtitle': 'JWT-Token in HTTP-Anfragen testen',
            'http.request_builder': 'HTTP-Request-Builder',
            'http.url_placeholder': 'https://api.example.com/endpoint',
            'http.send': 'Senden',
            'http.headers': 'Headers',
            'http.body': 'Body',
            'http.authorization': 'Autorisierung',
            'http.headers_placeholder': 'Content-Type: application/json\nUser-Agent: JWT-Analyzer',
            'http.body_placeholder': '{\n  "data": "beispiel"\n}',
            'http.bearer_token': 'Bearer Token',
            'http.custom_header': 'Benutzerdefinierter Header',
            'http.token_placeholder': 'JWT-Token hier einfügen...',
            'http.response': 'Antwort',
            'http.response_body': 'Antwort',
            'http.response_headers': 'Headers',

            'base64.title': 'Base64-Tools',
            'base64.subtitle': 'Base64-Strings kodieren und dekodieren',
            'base64.encoder_decoder': 'Base64-Encoder/Decoder',
            'base64.plain_text': 'Klartext',
            'base64.base64': 'Base64',
            'base64.plain_placeholder': 'Klartext zum Kodieren eingeben...',
            'base64.base64_placeholder': 'Base64-String zum Dekodieren eingeben...',
            'base64.encode': 'Kodieren',
            'base64.decode': 'Dekodieren',

            'help.title': 'Hilfe & Dokumentation',
            'help.subtitle': 'Lernen Sie, wie Sie den JWT Security Analyzer effektiv verwenden',
            'help.getting_started': 'Erste Schritte',
            'help.step1': 'Beginnen Sie mit dem JWT Decoder, um vorhandene Token zu analysieren und ihre Struktur zu verstehen',
            'help.step2': 'Verwenden Sie den JWT Encoder, um benutzerdefinierte Token mit eigenem Header, Payload und Signatur zu erstellen',
            'help.step3': 'Führen Sie eine Sicherheitsanalyse durch, um potenzielle Schwachstellen in Ihren Token zu identifizieren',
            'help.step4': 'Generieren Sie Angriffsvektoren, um die JWT-Implementierung Ihrer Anwendung zu testen',
            'help.step5': 'Verwenden Sie Brute Force, um die Stärke von HMAC-Geheimnissen zu testen',
            'help.step6': 'Generieren Sie sichere Schlüssel mit dem Schlüsselgenerator für den Produktionseinsatz',
            'help.key_features': 'Hauptfunktionen:',
            'help.feature1': 'Umfassende JWT-Token-Dekodierung und -Analyse',
            'help.feature2': 'Benutzerdefinierte Token-Generierung mit mehreren Algorithmen',
            'help.feature3': 'Erweiterte Sicherheitsschwachstellenerkennung',
            'help.feature4': '16+ Angriffsvektor-Generatoren für Penetrationstests',
            'help.feature5': 'Wörterbuch-basiertes Geheimnis-Brute-Forcing',
            'help.feature6': 'Sichere HMAC- und RSA-Schlüsselgenerierung',
            'help.feature7': 'Token-Signaturvalidierung und -verifizierung',
            'help.feature8': 'HTTP-Request-Tests mit JWT-Token',
            'help.supported_algorithms': 'Unterstützte Algorithmen',
            'help.hmac_algorithms': 'HMAC-Algorithmen:',
            'help.rsa_algorithms': 'RSA-Algorithmen:',
            'help.ecdsa_algorithms': 'ECDSA-Algorithmen:',
            'help.pss_algorithms': 'PSS-Algorithmen:',
            'help.other_algorithms': 'Andere:',
            'help.algorithm_notes': 'Algorithmus-Hinweise:',
            'help.algorithm_note1': 'HMAC-Algorithmen verwenden symmetrische Schlüssel (geteiltes Geheimnis)',
            'help.algorithm_note2': 'RSA-Algorithmen verwenden asymmetrische Schlüssel (private/öffentliche Schlüsselpaare)',
            'help.algorithm_note3': 'Der "none"-Algorithmus deaktiviert die Signaturverifizierung (gefährlich!)',
            'help.algorithm_note4': 'Höhere Bitlängen (384, 512) bieten stärkere Sicherheit',
            'help.algorithm_note5': 'ECDSA bietet gleichwertige Sicherheit mit kleineren Schlüsselgrößen',
            'help.algorithm_note6': 'PSS-Algorithmen bieten zusätzliche Sicherheit durch probabilistische Signaturen',
            'help.attack_vectors': 'Angriffsvektoren-Leitfaden',
            'help.algorithm_none_help': 'Algorithmus-None-Angriff:',
            'help.algorithm_none_desc': 'Entfernt die Signaturverifizierung durch Änderung des Algorithmus auf "none". Testen Sie, ob Ihre Anwendung Algorithmen validiert.',
            'help.algorithm_confusion_help': 'Algorithmus-Verwirrung:',
            'help.algorithm_confusion_desc': 'Ändert RS256 zu HS256 und verwendet den öffentlichen Schlüssel als HMAC-Geheimnis. Nutzt Anwendungen aus, die Algorithmustypen nicht ordnungsgemäß validieren.',
            'help.weak_secret_help': 'Schwache-Geheimnis-Angriff:',
            'help.weak_secret_desc': 'Zielt auf HMAC-signierte JWTs mit vorhersagbaren Geheimnissen ab. Verwendet Wörterbuchangriffe, um schwache Passwörter wie "secret", "password" oder "key" zu entdecken.',
            'help.token_replay_help': 'Token-Replay-Angriff:',
            'help.token_replay_desc': 'Nutzt Token ohne ordnungsgemäße Ablaufzeit oder zeitbasierte Claims aus. Entfernt exp-, nbf- und iat-Claims, um unbegrenzte Token-Wiederverwendung zu ermöglichen.',
            'help.jwk_injection_help': 'JWK-Injektion:',
            'help.jwk_injection_desc': 'Injiziert einen bösartigen JWK (JSON Web Key) in den Token-Header, um die Signaturverifizierung zu umgehen.',
            'help.kid_injection_help': 'Kid-Parameter-Injektion:',
            'help.kid_injection_desc': 'Nutzt den "kid" (Key ID) Parameter für Pfad-Traversal und Injektionsangriffe aus, wenn Anwendungen ihn unsicher verwenden.',
            'help.jku_hijack_help': 'JKU-URL-Entführung:',
            'help.jku_hijack_desc': 'Lässt den "jku"-Parameter auf angreifer-kontrollierte Server zeigen, die bösartige JWK-Sets für Signatur-Bypass hosten.',
            'help.x5u_exploit_help': 'X5U-Zertifikat-Exploit:',
            'help.x5u_exploit_desc': 'Nutzt den "x5u"-Parameter aus, indem er auf bösartige X.509-Zertifikatsketten zeigt, wodurch Signatur-Bypass und SSRF-Angriffe ermöglicht werden.',
            'help.jwt_smuggling_help': 'JWT-Schmuggel:',
            'help.jwt_smuggling_desc': 'Nutzt Parsing-Unterschiede zwischen JWT-Bibliotheken aus, um bösartige Token zu schmuggeln.',
            'help.nested_jwt_help': 'Verschachtelter JWT-Angriff:',
            'help.nested_jwt_desc': 'Platziert einen JWT innerhalb der Payload eines anderen, um Validierungslogik auszunutzen und Privilegieneskalation durch Token-Verwirrung zu erreichen.',
            'help.audience_confusion_help': 'Zielgruppen-Verwirrung:',
            'help.audience_confusion_desc': 'Nutzt schwache Audience-Claim-Validierung aus, um Cross-Service-Token-Wiederverwendung und Privilegieneskalation zu ermöglichen.',
            'help.parameter_pollution_help': 'Parameter-Verschmutzung:',
            'help.parameter_pollution_desc': 'Verwendet doppelte JSON-Schlüssel mit widersprüchlichen Werten, um Parsing-Unterschiede zwischen Bibliotheken auszunutzen.',
            'help.timing_attack_help': 'Timing-Angriff:',
            'help.timing_attack_desc': 'Analysiert Signaturverifizierungs-Timing, um Schlüsselmaterial zu extrahieren oder Sicherheit durch statistische Timing-Analyse zu umgehen.',
            'help.jwt_sidejacking_help': 'JWT-Sidejacking:',
            'help.jwt_sidejacking_desc': 'Zielt auf JWT-spezifische Session-Management-Schwachstellen ab, einschließlich Token-Hijacking, Fixierung und Cross-Site-Diebstahl.',
            'help.jwks_poisoning_help': 'JWKS-Cache-Vergiftung:',
            'help.jwks_poisoning_desc': 'Vergiftet JSON Web Key Set-Caches mit bösartigen Schlüsseln, um alle Anwendungen zu kompromittieren, die den vergifteten Cache verwenden.',
            'help.quantum_prep_help': 'Quantum-Prep-Angriff:',
            'help.quantum_prep_desc': 'Bewertet JWT-Resistenz gegen zukünftige Quantencomputing-Angriffe und empfiehlt Post-Quantum-Kryptographie-Migration.',
            'help.tools_guide': 'Tools-Leitfaden',
            'help.decoder_help': 'JWT Decoder:',
            'help.decoder_desc': 'Fügen Sie einen beliebigen JWT-Token ein, um seinen Header, Payload und Signatur in menschenlesbarem Format zu sehen. Analysiert Claims und bietet Token-Struktur-Einblicke.',
            'help.encoder_help': 'JWT Encoder:',
            'help.encoder_desc': 'Erstellen Sie benutzerdefinierte JWT-Token durch Angabe von Header, Payload, Algorithmus und Geheimnis. Unterstützt Vorlagen für häufige Token-Strukturen.',
            'help.security_help': 'Sicherheitsanalyse:',
            'help.security_desc': 'Umfassender Schwachstellenscanner, der auf häufige JWT-Sicherheitsprobleme prüft und eine Sicherheitsbewertung liefert.',
            'help.bruteforce_help': 'Brute Force:',
            'help.bruteforce_desc': 'Testen Sie die HMAC-Geheimnissstärke mit Wörterbuchangriffen. Laden Sie häufige Geheimnisse oder benutzerdefinierte Wörterlisten, um schwache Token zu knacken.',
            'help.keygen_help': 'Schlüsselgenerator:',
            'help.keygen_desc': 'Generieren Sie kryptographisch sichere HMAC-Geheimnisse und RSA-Schlüsselpaare für den Produktionseinsatz. Unterstützt mehrere Schlüsselgrößen.',
            'help.validator_help': 'Token-Validator:',
            'help.validator_desc': 'Verifizieren Sie JWT-Token-Signaturen und validieren Sie Claims gegen bereitgestellte Geheimnisse oder öffentliche Schlüssel.',
            'help.http_tester_help': 'HTTP-Tester:',
            'help.http_tester_desc': 'Testen Sie JWT-Token in echten HTTP-Anfragen. Konfigurieren Sie Headers, Body und Autorisierung, um zu sehen, wie sich Token in API-Aufrufen verhalten.',
            'help.base64_tools_help': 'Base64-Tools:',
            'help.base64_tools_desc': 'Kodieren Sie Klartext zu Base64 oder dekodieren Sie Base64-Strings zurück zu Klartext. Nützlich für manuelles Erstellen von JWT-Komponenten.',
            'help.about': 'Über',
            'help.description': 'Umfassende JWT-Sicherheitstestsuite',
            'help.built_with': 'www.bavamont.com',
            'help.powered_by': 'Entwickelt für Entwickler',
            'help.auto_updates': 'Updates mit neuen Angriffsvektoren und Funktionen',
            'help.security_disclaimer_title': 'Haftungsausschluss:',
            'help.security_disclaimer': 'Dieses Tool ist nur für legitime Sicherheitstests und Bildungszwecke konzipiert. Stellen Sie immer sicher, dass Sie über die entsprechende Berechtigung verfügen, bevor Sie ein System testen. Benutzer sind dafür verantwortlich, geltende Gesetze und Vorschriften einzuhalten.',

            'updater.title': 'App-Updater',
            'updater.checking': 'Suche nach Updates...',
            'updater.available': 'Update verfügbar',
            'updater.not_available': 'Sie verwenden die neueste Version',
            'updater.downloading': 'Update wird heruntergeladen...',
            'updater.downloaded': 'Update heruntergeladen. Zum Installieren neu starten.',
            'updater.error': 'Update fehlgeschlagen',
            'updater.install_now': 'Jetzt Installieren',
            'updater.install_later': 'Später Installieren',
            'updater.skip_version': 'Diese Version Überspringen',
            'updater.check_updates': 'Nach Updates Suchen',
            'updater.current_version': 'Aktuelle Version:',
            'updater.new_version': 'Neue Version:',
            'updater.release_notes': 'Versionshinweise',
            'updater.download_progress': 'Download-Fortschritt:',

            'common.browse': 'Durchsuchen',
            'common.ok': 'OK',
            'common.cancel': 'Abbrechen',
            'common.yes': 'Ja',
            'common.no': 'Nein',
            'common.apply': 'Anwenden',
            'common.reset': 'Zurücksetzen',
            'common.default': 'Standard',
            'common.copy': 'Kopieren',
            'common.save': 'Speichern',
            'common.load': 'Laden',
            'common.export': 'Exportieren',
            'common.import': 'Importieren',
            'common.delete': 'Löschen',
            'common.edit': 'Bearbeiten',
            'common.view': 'Anzeigen',
            'common.download': 'Herunterladen',
            'common.upload': 'Hochladen',
            'common.refresh': 'Aktualisieren',
            'common.search': 'Suchen',
            'common.filter': 'Filtern',
            'common.sort': 'Sortieren',
            'common.settings': 'Einstellungen',
            'common.preferences': 'Einstellungen',
            'common.options': 'Optionen',
            'common.tools': 'Tools',
            'common.utilities': 'Dienstprogramme',
            'common.back': 'Zurück',
            'common.next': 'Weiter',
            'common.previous': 'Vorherige',
            'common.continue': 'Fortfahren',
            'common.finish': 'Beenden',
            'common.start': 'Start',
            'common.stop': 'Stopp',
            'common.pause': 'Pause',
            'common.resume': 'Fortsetzen',
            'common.retry': 'Wiederholen',
            'common.skip': 'Überspringen',
            'common.ignore': 'Ignorieren',
            'common.warning': 'Warnung',
            'common.error': 'Fehler',
            'common.success': 'Erfolg',
            'common.info': 'Information',
            'common.loading': 'Lädt...',
            'common.processing': 'Verarbeitung...',
            'common.connecting': 'Verbinden...',
            'common.disconnected': 'Getrennt',
            'common.connected': 'Verbunden',
            'common.online': 'Online',
            'common.offline': 'Offline',

            'toast.update_checking': 'Suche nach Updates...',
            'toast.update_available': 'Update verfügbar!',
            'toast.update_not_available': 'Keine Updates verfügbar',
            'toast.update_downloaded': 'Update bereit zur Installation',
            'toast.update_error': 'Update-Prüfung fehlgeschlagen',
            'toast.invalid_token': 'Ungültiges JWT-Token-Format',
            'toast.provide_header_payload': 'Bitte Header und Payload angeben',
            'toast.hmac_secret_required': 'HMAC-Geheimnis ist für diesen Algorithmus erforderlich',
            'toast.rsa_key_required': 'RSA-Privatschlüssel ist für diesen Algorithmus erforderlich',
            'toast.ecdsa_key_required': 'ECDSA-Privatschlüssel ist für diesen Algorithmus erforderlich',
            'toast.token_generated': 'JWT-Token erfolgreich generiert',
            'toast.token_generation_failed': 'Token-Generierung fehlgeschlagen',
            'toast.provide_token_analyze': 'Bitte JWT-Token für Analyse angeben',
            'toast.security_analysis_failed': 'Sicherheitsanalyse fehlgeschlagen',
            'toast.provide_token_attack': 'Bitte Ziel-JWT-Token angeben',
            'toast.unknown_attack': 'Unbekannter Angriffstyp',
            'toast.attack_generation_failed': 'Angriffsgenerierung fehlgeschlagen',
            'toast.provide_token_crack': 'Bitte JWT-Token zum Knacken angeben',
            'toast.provide_wordlist': 'Bitte Wörterliste angeben',
            'toast.wordlist_empty': 'Wörterliste ist leer',
            'toast.invalid_token_crack': 'Ungültiger JWT-Token zum Knacken',
            'toast.brute_force_complete': 'Brute-Force-Angriff abgeschlossen - kein Geheimnis gefunden',
            'toast.secret_cracked': 'Geheimnis erfolgreich geknackt!',
            'toast.common_secrets_loaded': 'Häufige Geheimnisse geladen:',
            'toast.hmac_secret_generated': 'HMAC-Geheimnis generiert mit',
            'toast.rsa_keys_generated': 'RSA-Schlüsselpaar generiert mit',
            'toast.ecdsa_keys_generated': 'ECDSA-Schlüsselpaar generiert mit',
            'toast.key_generation_failed': 'Schlüsselgenerierung fehlgeschlagen',
            'toast.provide_token_validate': 'Bitte JWT-Token zur Validierung angeben',
            'toast.provide_secret_key': 'Bitte Geheimnis oder öffentlichen Schlüssel angeben',
            'toast.token_validation_failed': 'Token-Validierung fehlgeschlagen',
            'toast.enter_url': 'Bitte URL eingeben',
            'toast.request_failed': 'HTTP-Anfrage fehlgeschlagen',
            'toast.request_config_error': 'Anfragekonfigurationsfehler',
            'toast.enter_text_encode': 'Bitte Text zum Kodieren eingeben',
            'toast.text_encoded': 'Text zu Base64 kodiert',
            'toast.enter_base64_decode': 'Bitte Base64-String zum Dekodieren eingeben',
            'toast.base64_decoded': 'Base64 erfolgreich dekodiert',
            'toast.invalid_base64': 'Ungültiger Base64-String',
            'toast.copied_clipboard': 'In Zwischenablage kopiert',
            'toast.copy_failed': 'Kopieren fehlgeschlagen',
            'toast.copy_not_supported': 'Zwischenablage nicht unterstützt',
            'toast.file_loaded': 'Datei geladen mit',
            'toast.file_load_failed': 'Datei laden fehlgeschlagen',
            'toast.file_load_error': 'Datei Ladefehler',
            'toast.no_token_data': 'Keine Token-Daten verfügbar',
            'toast.token_sent_encoder': 'Token-Daten an Encoder gesendet',
            'toast.secret_loaded_encoder': 'Geheimnis im Encoder geladen',
            'toast.detailed_scan_complete': 'Detaillierte Sicherheitsprüfung abgeschlossen',

            'claims.issuer': 'Aussteller',
            'claims.subject': 'Betreff',
            'claims.audience': 'Zielgruppe',
            'claims.expiration': 'Ablaufzeit',
            'claims.not_before': 'Nicht vor',
            'claims.issued_at': 'Ausgestellt am',
            'claims.jwt_id': 'JWT-ID',
            'claims.scope': 'Bereich',
            'claims.roles': 'Rollen',
            'claims.permissions': 'Berechtigungen',
            'claims.nonce': 'Nonce',
            'claims.authorized_party': 'Autorisierte Partei',
            'claims.at_hash': 'Access Token Hash',
            'claims.c_hash': 'Code Hash',
            'claims.issuer_desc': 'Der Prinzipal, der das JWT ausgestellt hat',
            'claims.subject_desc': 'Der Prinzipal, der das Subjekt des JWT ist',
            'claims.audience_desc': 'Die Empfänger, für die das JWT bestimmt ist',
            'claims.expiration_desc': 'Die Ablaufzeit, zu oder nach der das JWT NICHT akzeptiert werden DARF',
            'claims.not_before_desc': 'Die Zeit, vor der das JWT NICHT akzeptiert werden DARF',
            'claims.issued_at_desc': 'Die Zeit, zu der das JWT ausgestellt wurde',
            'claims.jwt_id_desc': 'Eine eindeutige Kennung für das JWT',
            'claims.scope_desc': 'Leerzeichengetrennte Liste von Bereichen, die mit dem Token verknüpft sind',
            'claims.roles_desc': 'Benutzerrollen oder -gruppen',
            'claims.permissions_desc': 'Spezifische Berechtigungen, die dem Token gewährt wurden',
            'claims.nonce_desc': 'String-Wert, der verwendet wird, um eine Client-Sitzung mit einem ID-Token zu verknüpfen',
            'claims.authorized_party_desc': 'Die Partei, an die das ID-Token ausgestellt wurde',
            'claims.at_hash_desc': 'Access Token Hash-Wert',
            'claims.c_hash_desc': 'Code Hash-Wert',

            'vulns.algorithm_none': 'Algorithmus "none" Schwachstelle',
            'vulns.algorithm_none_desc': 'Token verwendet den "none"-Algorithmus, der die Signaturverifizierung deaktiviert',
            'vulns.algorithm_none_impact': 'Vollständige Authentifizierungsumgehung - jeder kann gültige Token erstellen',
            'vulns.algorithm_none_rec': 'Verwenden Sie niemals den "none"-Algorithmus in Produktionsumgebungen',
            'vulns.weak_algorithm': 'Schwacher Algorithmus',
            'vulns.weak_algorithm_desc': 'Token verwendet HS256, das anfällig für Brute-Force-Angriffe mit schwachen Geheimnissen sein kann',
            'vulns.weak_algorithm_impact': 'Potenzielle Geheimniskompromittierung durch Wörterbuchangriffe',
            'vulns.weak_algorithm_rec': 'Verwenden Sie stärkere Algorithmen wie HS384/HS512 oder RSA-basierte Algorithmen',
            'vulns.missing_algorithm': 'Fehlender Algorithmus',
            'vulns.missing_algorithm_desc': 'Token-Header gibt keinen Algorithmus an',
            'vulns.missing_algorithm_impact': 'Undefiniertes Verhalten - kann zu unsicheren Algorithmen führen',
            'vulns.missing_algorithm_rec': 'Geben Sie immer explizit den Algorithmus im Token-Header an',
            'vulns.missing_expiration': 'Fehlende Ablauf-Claim',
            'vulns.missing_expiration_desc': 'Token hat keine Ablaufzeit (exp claim)',
            'vulns.missing_expiration_impact': 'Token laufen nie ab, was unbegrenzte Wiederverwendung ermöglicht',
            'vulns.missing_expiration_rec': 'Fügen Sie immer eine Ablaufzeit in Token ein',
            'vulns.expired_token': 'Abgelaufener Token',
            'vulns.expired_token_desc': 'Token hat seine Ablaufzeit überschritten',
            'vulns.expired_token_impact': 'Token sollte von Anwendungen nicht akzeptiert werden',
            'vulns.expired_token_rec': 'Stellen Sie sicher, dass Anwendungen Ablaufzeiten ordnungsgemäß validieren',
            'vulns.missing_issued_at': 'Fehlende Ausstellungszeit-Claim',
            'vulns.missing_issued_at_desc': 'Token gibt nicht an, wann es ausgestellt wurde (iat claim)',
            'vulns.missing_issued_at_impact': 'Schwierig, Token-Alter zu verfolgen und zeitbasierte Richtlinien zu implementieren',
            'vulns.missing_issued_at_rec': 'Fügen Sie die "iat" (issued at) Claim in Token ein',
            'vulns.missing_issuer': 'Fehlende Aussteller-Claim',
            'vulns.missing_issuer_desc': 'Token gibt nicht an, wer es ausgestellt hat (iss claim)',
            'vulns.missing_issuer_impact': 'Kann Token-Herkunft nicht verifizieren oder aussteller-basierte Validierung implementieren',
            'vulns.missing_issuer_rec': 'Fügen Sie die "iss" (issuer) Claim ein, um Token-Quelle zu identifizieren',
            'vulns.admin_token': 'Administrativer Token',
            'vulns.admin_token_desc': 'Token enthält administrative Privilegien (Betreff ist "admin")',
            'vulns.admin_token_impact': 'Hochprivilegierter Token, der bei Kompromittierung erheblichen Schaden verursachen könnte',
            'vulns.admin_token_rec': 'Verwenden Sie rollenbasierte Zugriffskontrolle anstelle von betreffbasierter Admin-Erkennung',
            'vulns.malformed_token': 'Fehlgeformter Token',
            'vulns.malformed_token_desc': 'Token hat nicht die korrekte dreiteilige Struktur',
            'vulns.malformed_token_impact': 'Token kann nicht ordnungsgemäß validiert werden',
            'vulns.malformed_token_rec': 'Stellen Sie sicher, dass Token dem ordnungsgemäßen JWT-Format folgen (header.payload.signature)',
            'vulns.missing_signature': 'Fehlende Signatur',
            'vulns.missing_signature_desc': 'Token hat eine leere Signaturkomponente',
            'vulns.missing_signature_impact': 'Token kann nicht auf Authentizität überprüft werden',
            'vulns.missing_signature_rec': 'Stellen Sie sicher, dass Token ordnungsgemäß mit einem sicheren Algorithmus signiert sind',
            'vulns.large_token': 'Übergroßer Token',
            'vulns.large_token_desc': 'Token überschreitet empfohlene Größenlimits',
            'vulns.large_token_impact': 'Kann Leistungsprobleme verursachen oder HTTP-Header-Limits überschreiten',
            'vulns.large_token_rec': 'Halten Sie Token unter 8KB und minimieren Sie die Payload-Größe',
            'vulns.invalid_base64': 'Ungültige Base64-Kodierung',
            'vulns.invalid_base64_desc': 'Token-Teile enthalten ungültige Base64URL-Kodierung',
            'vulns.invalid_base64_impact': 'Token wird möglicherweise nicht von allen JWT-Bibliotheken korrekt verarbeitet',
            'vulns.invalid_base64_rec': 'Stellen Sie ordnungsgemäße Base64URL-Kodierung ohne Polsterung sicher',
            'vulns.jwk_injection': 'JWK-Injektions-Schwachstelle',
            'vulns.jwk_injection_desc': 'Token-Header enthält einen JWK (JSON Web Key), der bösartig sein könnte',
            'vulns.jwk_injection_impact': 'Angreifer kann den Verifizierungsschlüssel kontrollieren und die Signaturvalidierung umgehen',
            'vulns.jwk_injection_rec': 'Vertrauen Sie niemals in Token-Headern eingebetteten JWKs - verwenden Sie ein vertrauenswürdiges Schlüssel-Repository',
            'vulns.kid_path_traversal': 'Schlüssel-ID-Pfad-Traversal',
            'vulns.kid_path_traversal_desc': 'Der "kid"-Parameter enthält Pfad-Traversal-Sequenzen',
            'vulns.kid_path_traversal_impact': 'Potenzieller Dateisystemzugriff oder unbefugtes Schlüsselladen',
            'vulns.kid_path_traversal_rec': 'Validieren und bereinigen Sie den "kid"-Parameter gegen eine Whitelist',
            'vulns.kid_sql_injection': 'Schlüssel-ID-SQL-Injektion',
            'vulns.kid_sql_injection_desc': 'Der "kid"-Parameter enthält potenzielle SQL-Injektions-Payloads',
            'vulns.kid_sql_injection_impact': 'Datenbankkompromittierung wenn kid in SQL-Abfragen verwendet wird',
            'vulns.kid_sql_injection_rec': 'Verwenden Sie parametrisierte Abfragen und validieren Sie kid-Werte',
            'vulns.jku_hijacking': 'JKU-URL-Entführung',
            'vulns.jku_hijacking_desc': 'Token-Header enthält einen "jku"-Parameter, der auf eine externe URL zeigt',
            'vulns.jku_hijacking_impact': 'Angreifer kann bösartige JWK-Sets hosten, um Verifizierung zu umgehen',
            'vulns.jku_hijacking_rec': 'Erlauben Sie nur vertrauenswürdige JKU-URLs oder deaktivieren Sie JKU-Verarbeitung vollständig',
            'vulns.x5u_exploit': 'X5U-Zertifikat-Exploit',
            'vulns.x5u_exploit_desc': 'Token-Header enthält einen "x5u"-Parameter für X.509-Zertifikatskette',
            'vulns.x5u_exploit_impact': 'Angreifer kann bösartige Zertifikatsketten bereitstellen',
            'vulns.x5u_exploit_rec': 'Validieren Sie Zertifikatsketten gegen vertrauenswürdige CAs und implementieren Sie URL-Beschränkungen',
            'vulns.multi_audience': 'Mehrfach-Zielgruppen-Schwachstelle',
            'vulns.multi_audience_desc': 'Token hat mehrere Zielgruppen, was Verwirrung verursachen kann',
            'vulns.multi_audience_impact': 'Token-Wiederverwendung zwischen Diensten, die es nicht akzeptieren sollten',
            'vulns.multi_audience_rec': 'Verwenden Sie dienst-spezifische Token mit einzelnen Zielgruppenwerten',
            'vulns.nested_jwt': 'Verschachtelter JWT erkannt',
            'vulns.nested_jwt_desc': 'Token enthält einen anderen JWT in seiner Payload',
            'vulns.nested_jwt_impact': 'Komplexe Validierungslogik kann zu Berechtigungseskalation führen',
            'vulns.nested_jwt_rec': 'Vermeiden Sie verschachtelte JWTs oder implementieren Sie sorgfältige Validierung innerer Token',
            'vulns.quantum_vulnerable': 'Quantum-anfälliger Algorithmus',
            'vulns.quantum_vulnerable_desc': 'Token verwendet einen Algorithmus, der anfällig für Quantencomputing-Angriffe ist',
            'vulns.quantum_vulnerable_impact': 'Zukünftige kryptographische Kompromittierung wenn Quantencomputer verfügbar sind',
            'vulns.quantum_vulnerable_rec': 'Planen Sie Migration zu Post-Quantum-Kryptographie-Algorithmen'
        }
    },

    init() {
        this.detectLanguage();
        this.setupLanguageSelector();
        this.translatePage();
    },

    detectLanguage() {
        const savedLanguage = localStorage.getItem('jwtAnalyzerLanguage');
        if (savedLanguage && this.translations[savedLanguage]) {
            this.currentLanguage = savedLanguage;
        } else {
            const systemLanguage = navigator.language.substring(0, 2);
            if (this.translations[systemLanguage]) {
                this.currentLanguage = systemLanguage;
            }
        }
    },

    setupLanguageSelector() {
        const selector = document.getElementById('language-selector');
        if (selector) {
            selector.value = this.currentLanguage;
            selector.addEventListener('change', (e) => {
                this.setLanguage(e.target.value);
            });
        }
    },

    setLanguage(language) {
        if (this.translations[language]) {
            this.currentLanguage = language;
            localStorage.setItem('jwtAnalyzerLanguage', language);
            this.translatePage();
        }
    },

    t(key, params = {}) {
        const translation = this.translations[this.currentLanguage]?.[key] ||
                          this.translations['en']?.[key] ||
                          key;

        let result = translation;
        Object.keys(params).forEach(param => {
            result = result.replace(`{${param}}`, params[param]);
        });

        return result;
    },

    translatePage() {
        document.querySelectorAll('[data-i18n]').forEach(element => {
            const key = element.getAttribute('data-i18n');
            element.textContent = this.t(key);
        });

        document.querySelectorAll('[data-i18n-placeholder]').forEach(element => {
            const key = element.getAttribute('data-i18n-placeholder');
            element.placeholder = this.t(key);
        });

        document.querySelectorAll('[data-i18n-title]').forEach(element => {
            const key = element.getAttribute('data-i18n-title');
            element.title = this.t(key);
        });

        document.title = this.t('app.title');
    }
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => i18n.init());
} else {
    i18n.init();
}

if (typeof module !== 'undefined' && module.exports) {
    module.exports = i18n;
}